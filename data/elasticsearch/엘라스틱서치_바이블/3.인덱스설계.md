## 인덱스 설정

인덱스를 생성할 때에는 인덱스의 동작에 관한 설정을 지정할 수 있다.

- `GET [인덱스 이름]/_settings` 으로 조회 가능
- `PUT [인덱스 이름]/_settings` + Request Body("settings" 포함)로 값 변경 가능
  - `number_of_shards`: 이 인데스가 데이터를 몇 개의 샤드로 쪼갤 것인지 지정하는 값. 샤드 갯수가 많으면 클러스터 성능이 떨이지고 적으면 샤드 하나의 크기가 너무 커짐. 바꾸기 어려우므로 신중하게 설정
  - `number_of_replicas`: 주 샤드 하나당 복제본 샤드를 몇 개 둘 것인지. 이 값이 0이면 복제본 샤드는 두지 않고 주 샤드만 둠.
  - `refresh_interval`: 해당 인덱스를 대상으로 refresh를 얼마나 자주 수행할 것인지를 결정. 명시적으로 설정하지 않으면 1초마다 refresh진행. 검색 쿼리가 30초 이내로 들어오지 않았으면 refresh 진행하지 않음. 


## 매핑과 필드 타입

매핑은 문서가 인덱스에 어떻게 색인되고 저장되는지 정의하는 부분
- 인덱스에 최초 문서를 생성하면 mappings 항목에 각 필드의 타입과 관련된 정보가 자동으로 새로 생긴 것을 확인할 수 있음.(이를 동적 매핑이라고 부름, 명시적으로 셋팅 가능하다.)
- 매핑 설정도 한 번 지정되면 사실상 변경이 불가능하다. (신규 매핑 설정은 그나마 자유로운 편)

### 필드 타입

|분류|종류|
|-----|-----|
|심플 타입| text, keyword, data, long,...|
|계층 구조를 지원하는 타입| object, nested,..|
|그 외 특수한 타입| geo_point, geo_shape,...|

여기서 주의해야할 점은 object타입과 nested타입에서 배열을 관리하는 방법이 다르다는 것이다. nested타입과 달리 object타입에서는 각 배열의 요소를 독립적인 객체로 인지하지 않는다.

예를 들어서

item: {
    [
        {
            "price": 13,
            "name: "item1"
        },
        {
            "price": 210,
            "name": "item2"
        }
        
    ]
}

라는 객체가 있을때 object로 선언되어있으면 13이면서 item2인 객체를 찾을때 두 개 다 검색되지만 nested형은 검색되지 않는다.
object형은 값을 평탄화할 때 
{
    "item.price": [13,210],
    "item.name": ["item1","item2"]
}

이런식으로 저장하기 때문이다. 근데 **nested형은 저장하는 방식이 좀 달라서 검색할 때에는 nested쿼리라는 전용 쿼리를 이용해서 검색해야한다.** 그리고 저장하는 방식에 대한 오버헤드로 인해서 성능 문제가 있다. 따라서 무분별한 사용을 막기 위해 엘라스틱서치에서 제한을 걸어 놓았다. 따라서 이 값을 수정하여 잘못되면 OOM의문제를 겪을 수도 있다.

### text와 keyword타입

- text: 이 값으로 지정된 필드 값은 애널라이저가 적용된 후 색인됨. 따라서 값을 분석하여 여러 토큰으로 쪼개지고, 이를 기준으로 역새인을 구성. 
- keyword: 애널라이저로 분석하는 대신 노멀라이저를 사용. 간단한 전처리만을 거친 뒤 커다란 단일 텀(term)으로 역색인 구성
- term: 토큰에 후처리 작업 후 최종적으로 역색인에 들어가는 형태
  
만약 "Hello, World!"라는 문자열을 text와 keyword타입으로 지정하고 "hello"로 검색하였을 때 text타입으로 지정된 경우에만 검색된다. keyword는 여러 단어로 쪼개지 않고 전체 문자열로 역색인하기 떄문이다. 정확히 문자열을 입력해야 검색된다.

- 둘은 각자 다른 타입의 캐시를 사용하는데, keyword타입은 **doc_values**라는 캐시를 사용하고 text타입은 **fielddata**라는 캐시를 사용한다.
  - doc_values: 디스크 기반으로 한 자료 구조로 파일 시스템 캐시를 사용함. 디스크 기반이라 메모리 효율적. 기본은 활성화
  - fielddata: 역색인 전체를 힙메모리에 올려서 캐싱하여 오버헤드가 존재. 기본은 비활성화
  - 따라서 **정렬, 집계, 스크립트 연산**을 할 때에는 doc_values를 사용하는 keyword타입을 사용하는게 좋다.

### _source

문서 색인 시점에 엘라스틱서치에 전달된 원본 JSON 문서를 저장하는 메타데이터 필드. 이 값을 읽어서 클라이어트에 반환함. JSON 문서를 통째로 담기 때문에 디스크를 많이 사용함. 때문에 mappings에서 비활성화할 수도 있다. 비활성화하면 업데이트, update_by_query API를 사용할 수 없다. 업데이트 과정중 기존 문서의 내용과 병합하는 과정을 거치는데 _source가 없으면 읽을 수 없기 때문임. 비슷한 이유로 `reindex`작업도 불가능하다.

### index

이 속성은 해당 필드의 역색인을 만들 것인지를 지정함. 기본값은 true. false로 설정하면 해당 필드는 역색인이 없기에 일반적인 검색 대상이 되지 않음.(doc_values가 true면 검색 될 수 있음. 즉, 모든 상황에 해당되지 않음.)

### enabled

**이는 object타입의 필드에만 적용된다.** 이 값을 false로 지정하면 엘라스틱서치가 파싱조차 수행하지 않는다. 검색, 집계, 정렬등의 연산 불가능하다, 역색인을 생성하지 않아서 object타입이 아닌 데이터가 들어와도 타입 충돌이 발생하지 않는다.

예를 들어서

```json
{
  "notEnabled": {
    "mixedTypeArray": [
      "hello",
      4,
      false,
      {"foo": "bar"},
      null,
      [2,"E"]
      ]
  }
}
```
이런 값도 들어올 수 있다는 것.

## 애널라이저와 토크나이저

애널라이저는 0개 이상의 캐릭터 필터, 1개의 토크나이저, 0개 이상의 토큰 필터로 구성되며 동작방식도 위 순으로 수행된다. 
**캐릭터 필터**가 문자열을 변형시킨 뒤 **토큰나이저**가 여러 토큰으로 쪼갠다. **토큰 필터**를 적용해서 토큰들에 특정한 변형을 가해 최종적으로 분석 완료된 텀이 된다. 

- `POST _analyze`를 통해서 애널라이저 테스트가 가능하다.
- 캐릭터 필터: 텍스트를 캐릭터의 스트림으로 받아서 특정한 문자를 추가, 변경, 삭제함. 
  - 예를 들어서 html 과련 텍스트가 들어오면 캐릭터 필터를 통해 사람이 읽기 쉬운 문자열로 변환할 수 있음.
- 토크나이저: 캐릭터 스트림을 받아서 여러 토큰으로 쪼개어 토큰 스트림을 만듦. 내장된 토크나이저가 있음
  - standard 토크나이저: 내부 알괴리즘을 사용해서 텍스트를 단어 단위로 나눔. 
  - keyword 토크나이저: 들어온 텍스트를 쪼개지 않고 그대로 내보냄
  - ngram토크나이저: 텍스트를 min_gram 값 이상, max_gram 값 이하의 단위로 쪼갬. 
    - "token_chars"지시자를 통해서 좀더 커스텀한 제어가 가능하다.
  - edge_ngram 토크나이저: ngram 토크나이저와 유사하지만 모든 토큰의 시작 글자를 단어의 시작 글자로 고정하여 생성. "Hello, World"가 있으면 이를 쪼갤때 단어의 시작글자인 'H','W'가 무조건 시작글자에 위치해야함.
  - 등
- 토큰 필터
  - 토큰 스트림을 받아서 토큰을 추가, 변경, 삭제 
  - 내장 토큰 필터 종류는 lowercase, stop, synonym,..등이 있음.


이처럼 애널라이저는 캐릭터 필터, 토크나이저, 토큰 필터의 조합으로 만들어진다. 이를 이용한 커스텀 애널라이저, 디양한 내장 애널라이저가 존재한다. 이 애널라이저를 필드의 매핑에 적용하여 사용할 수 있다.

이러한 커스텀 애널라이저를 플러그인 형태로 추가하여 사용할 수도 있다. 터미널에서 `/bin/elasticsearch-plugin install [플러그인 명]`으로 설치가 가능하다. 

### 노멀라이저

애널라이저와 비슷한 노멀라이저는 text타입이 아닌 keyword타입에 적용된다.

## 템플릿

위의 과정을 보면 인덱스 생성시 설정해줘야하는 게 많은데 **템플릿**을 정의해 두면 인덱스 생성 시 사전 정의한 설정대로 인덱스가 생성되게 된다.

### 인덱스 템플릿

- `PUT _index_template/[템플릿 명]` + 바디: 인덱스 템플릿 생성
    - index_patterns: 인덱스 패턴을 지정하여 새 인덱스가 생성될 떄 이 패턴에 부합하면 템플릿이 적용됨을 의미한다.
    - priority: 여러 인덱스 템플릿이 위 조건에 해당할 경우 우선순위에 따라 적용될 인덱스 템플릿을 정할 수 있다.

### 컴포넌트 템플릿

인덱스 템플릿을 많이 만들면 이 템플릿끼리도 중복되는 구간이 생기는데, 이를 **컴포넌트 템플릿**을 통해 공통화할 수 있다. 

- `PUT _component_template/[컴포넌트 템플릿명]`: 컴포넌트 템플릿 생성
- 이를 생성하고 인덱스 템플릿을 생성할 때 `composed_of`라는 필드를 생성하여 적용시키면 된다.

### 레거시 템플릿

인덱스 템플릿과 컴포넌트 템플릿은 ES7.8 버전부터 추가되었는데, 이전 버전의 ES에서 사용하던 템플릿 API는 레거시 템플릿이 되었다. 호환성 이슈때문에 생긴듯 하다.

### 동적 템플릿

동적 템플릿은 인덱스에 새로 들어온 필드의 매핑을 사전에 정의한대로 동적 생성하는 기능. 즉, 정확히는 도큐먼트가 색인(indexing)될 때 발생한다.

### 빌트인 인덱스 템플릿

ES7.9.0 이상에서는 미리 정의된 인덱스 템플릿을 제공함. 로그나 메트릭은 편리하게 수집하기 위한 내장 템플릿들이 존재한다.

## 라우팅

엘라스틱서치가 인덱스를 구성하는 샤드 중 몇 번 샤드를 대상으로 작업을 수행할지 지정하기 위해 사용되는 값.

문서마다 지정할 수 있는데, 이 값을 통해 문서를 지정하면 특정 라우팅키로 하여금 문서를 검색할 수도 있다. 만약에 검색할 때 지정하지 않으면 특별한 조건 없이 문서 전체를 검색한다.
잘 이용하면 성능을 올릴 수 있지만 잘 사용하지 못하면 검색이 되지 않을 수 있다. 이런 주의점이 존재한다.

라우팅 설정 여부를 필수로 지정할 수도 있으니 운영에 참고하면 좋다.







