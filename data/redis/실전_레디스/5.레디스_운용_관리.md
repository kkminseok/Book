## 영속성

- 레디스는 스냅숏, AOF 두가지 방법으로 데이터의 영속성을 보장함. 이 두 방식을 조합하여 4개의 경우의수로 영속성을 설정할 수 있다.
    - 기본적으로 AOF는 비활성화
    - **스냅숏**은 특정 시점의 데이터베이스 내용을 RDB(Redis DataBase)라는 형식의 파일로 저장함.
    - **AOF(Append-Only File)** 은 추가 전용 파일을 의미. 레디스에 쓰기 작업을 수행하면 이 파일에 데이터를 차례로 기록하는 형식

## 스냅숏

특정 시점의 데이터들을 저장하는 기능
- 자동, 수동으로 생성 가능
    - 수동은 동기방식인 `SAVE`, 비동기방식인 `BGSAVE` 명령어로 가능
    - 동기방식인 SAVE는 운영환경에서는 비추천
    - 비동기방식은 동기방식보다 성능은 좋으나 fork로 프로세스를 따므로 이 동작 과정에서 성능의 영향을 미칠 수는 있음. 따라서 메모리양이 충분한지, 서비스에 지장이 없는 시간에 스냅숏을 생성하는지는 파악해둬야함.
    - 레디스 서버에 문제가 발생했을때, 마지막 스냅숏 이후 데이터는 손실이 있음.

## AOF

거의 실시간 백업처럼 작성 중인 파일 끝에 계속 추가하여 기록함.
- 위의 스냅숏 단점을 어느정도 보완해줌.
- 레디스 7.0 이후에는 멀티 파트 AOF가 탑재됨. 파일 출력하는 디렉터리가 'appenddirname'으로 분리, 여러 파일들이 추가됨.
- always, everysec, no 3가지로 자동생성 시점을 정할 수 있음.
    - 보통 성능 영향이 덜하면서 어느정도 성과를 기대할 수 있는 **everysec**을 많이씀.
- 파일 크기가 커지면 자동으로 AOF 재작성 기능을 통해 이미 삭제된 키, 같은 키에 여러 작업을 하는 등을 통합하여 파일 크기를 줄이는 작업이 수행됨.
    - 파일 크기를 비교하여 설정값을 초과하면 재작성함.
        - auto-aof-rewrite-percentage로 제어가 가능.
        - auto-aof-rewrite-min-size로 파일의 최소 크기 보장가능

### 레디스 7.0 이전의 동작박식

1. AOF 재작성을 위한 자식 프로세스를 포크하여 생성
2. 자식 프로세스가 새로운 AOF파일 생성한 후 재작성 결과 저장
3. 작업을 완료하면 부모 프로세스에 신호를 보냄.
4. 부모 프로세스는 포크 이후의 쓰기 작업 내용을 버퍼에 저장해두었다가 자식 프로세스에 전달
5. 자식 프로세스는 이 데이터의 차이를 AOF파일에 반영
6. 오래된 AOF파일을 신규 AOF파일로 교체

### 레디스 7.0 이후의 동작방식(멀티 파트 AOF)

1. AOF 재작성을 위한 자식 프로세스를 포크하여 생성
2. 부모 프로세스는 추가용 AOF파일을 생성(incr.aof 파일)
3. 자식 프로세스는 재작성 로직을 실행하여 새로운 베이스 AOF파일을 생성(base.aof파일)
4. 부모 프로세스가 새롭게 생성된 베이스 파일과 추가 파일의 정보를 임시로 생성된 매니페스트 파일에 업데이트(manifest.aof 파일)
5. 새로운 베이스 파일과 추가 파일이 준비되면, 매니페스트 파일을 반영하기 위해 교체
6. 오래된 베이스 파일과 추가파일을 히스토리 파일로 변환 후 원래 파일 삭제

부모 프로세스가 자식 프로세스로 추가 데이터를 전송하는 과정이 필요없어져서 CPU 처리 시간이 줄어듦

- 다만 이러한 동작 방식으로 인해서 백업 시 AOF 재작성을 일시적으로 비활성화 하지않으면 파일이 망가질 수 있음.

```sh
CONFIG SET aof-rewrite-incremental-fsync no
CONFIG SET auto-aof-rewrite-percentage 0
```

이러한 옵션을 추가하여 임시적으로 비활성화하여 백업해야함.


- 레디스는 데이터 영속화 기능이 있지만, 예기치 않게 데이터가 삭제될 수 있음. 원인을 고민해봐야함.
    - 엔진 재시작
    - 레디스 서버 전체 장애
    - 명령어 실행(FLUSH 등 명령어)
    - TTL 만료
    - 강제 제거
    - 비동기 레플리케이션
    - 레디스 클러스트의 네트워크 단절
    - 키이름 잘못 설정 등과 같은 이슈

등이 있다.

레디스 7.0부터는 PITR이라는 특정 시점으로 상태를 돌릴 수 있는데 AOF 파일과 호환성 이슈로 기본 설정은 비활성화 되어있다.


### 읽기관점 아키텍처

- 지연로딩 패턴, Read-Through 패턴 2개 있다.
    - 지연로딩: 레디스를 DB보다 앞단에 둬서 데이터를 가져오는 방식
        - 지연시간 최소화, 무분별한 공간사용 x, 캐시 미스 시 오버헤드 큼
    - Read-Through: 지연로딩과 같지만 데이터베이스에서 데이터 읽을때 애플리케이션단에서 하지 않는다고는 하지만.. 하는듯하다


### 쓰기 관점 아키텍처

- Write-Through: 데이터베이스에 데이터 저장 후 레디스에도 저장
    - 최신상태유지, 하지만 사용하지 않는 캐시 데이터 생성 가능성 존재
- Write-Back: 캐시에 저장 후 일정시간 뒤 DB를 비동기 방식으로 주기적 업데이트
    - 오버헤드 줄일 수 있음, 데이터 손실 발생 시나리오 충분히 검토 필요.
- Write-Around: 데이터베이스에 데이터를 저장하고 캐시는 읽을때 Lazy하게 채움.
    - 데이터 손실 위험도 적음, 쓰기 트래픽 적음


## 모범사례

- 캐시서버로 사용하는 경우 사라져도 되는 데이터들을 넣을꺼니까 TTL을 애용하자.
- maxmemory-policy, maxClients, 백오프 지수를 통한 재시도 방법 등을 검토하자.

## 캐시 노드 크기 조정

레디스 클러스터 사용할 것인지에 대한 기준

- 부하가 높은 쓰기 작업을 처리하는 경우, 높은 가용성이 요구되는 경우 but 러닝커브 존재
- 노드양이 많다고 성능이 향상되는건 아님. 헬스 체크로 인한 오버헤드가 증가할 수도 있음.
- 자세한 설명은 8장에 나온다고함.

## 설정파일 redis.conf

- 여러 지시자에 대한 설명(사실상 모든)
- `INFO server`명령어로 파일위치 확인가능
- `CONFIG SET` 명령어로 설정 변경을 재시작없이 가능
- 책에서는 네트워크, TLS, 레플리케이션, 클러스터, ACL, 클라이언트 추적, 보안, 클라이언트, 메모리 제어, 단편화, 타이머 이벤트, LazyFree, 멀티 스레드, 커널, 슬로우 로그, 지연 모니터, 지연 트래킹, 키공간 알림, 내부 인코딩 관련, CPU, 셧다운, 등 에 대한 지시자들을 전부 적어놨는데 이걸 다 정리하는건 의미가 없어보임.
    - 이렇게 적으니 진짜 많다.. 이걸 50%라도 활용할 수 있는 사람은 DBA직군이겠지?


## 보안

- Redis 6.0 부터는 ACL기능이 존재하여 접근 제어가 가능(키 접근제어, 명령어 제어 가능)
- Redis 7.0에는 강화되어 한 사용자에게 여러 독립적인 규칙을 지정할 수 있는 기능, 읽기 전용 혹은 쓰기 전용을 지정할 수 있는 키 허용 기능이 추가
- `ACL setuser ~`로 ACL 지정가능
- Redis 7.0부터는 `DRYRUN` 명령어를 통해 ACL 기능 테스트가 가능하다.(명령어를 실제 적용하지 않는다.)
- 여러 ACL관련 명령어들이 있으니 참고

## 벤치마크

- `redis-benchmark` 명령어를 통해 성능 테스트 가능
    - redis가 설치되면 기본적으로 설치되어있으므로 별도 설치 필요 없음.
    예시) `redis-benchmark -h 127.0.0.1  -p 6379 -n 100000 -r 10000 -P 130 -c 100 -d 15`    

- c: 병렬접속할 클라이언트 수 지정
- n: 요청 총 갯수
- threads: 멀티쓰레드 활성화
- cluster: 클러스터 모드 활성화
-  P: 파이프라인에서 처리될 요청 수
- r: 명령어에 사용될 키 공간
- t: 벤치마크에 사용할 명령어 목록
- d: SET/GET 명령어를 수행할 때 전송할 데이터 크기 바이트 단위로 지정
...

등이 있다.

## 멀티스레드

- 레디스가 **주로** 싱글 스레드로 요청을 처리하지만 부분적으로 멀티 스레드 처리를 함.
    - `UNLINK` 명령어가 대표적, 또는 AOF 쓰기, RDB백업 등
        - 삭제할 키를 백그라운드에서 큐에 넣어두기 때문에 다른 스레드에서 의해 비동기적으로 순차 삭제가 가능
- 정확히는 I/O요청,응답에서는 멀티쓰레드로 동작할 수 있지만 분석된 명령 내용을 실행하는 데이터 접근 부분은 싱글 스레드로 동작함.
- io-threads로 멀티쓰레드 수 제어 가능
    - 이 값을 8보다 크게 설정해도 큰 도움이 되지 않는다고 공식적으로 언급하고 있지만 적용해봐야 아는거라는게 결론
- CPU를 많이 소모하기에 기본적으로 비활성화 되어 있다.
- 멀티 스레드 처리 활성화하면 TLS기능을 사용할 수 없다.


## 디버그

- `DEBUG HELP` 로 디버그 명령어 관련 명령어들을 확인할 수 있다.
- 이렇게 봤을때는 잘 사용하기가 어려워 보여서 일단 이런게 있구나 하고 넘어갔다.



## 후기

- 5장부터는 운영에대한 이야기라고한다. 기대되었다.
- 스냅숏, AOF에 대한 상세한내용, 나름 최신인 7버전에 대한 이야기도 너무 만족스러웠다. 내용이 조금 어려운 편이다.
- 전반적으로 내가 원하는 내용이였고, 벤치마크, ACL 등 실무에서 적용해볼법한 것들도 많이 보였다.