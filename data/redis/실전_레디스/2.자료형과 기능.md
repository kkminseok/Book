## 2. 자료형과 기능

### 주요 자료형
- String
- List
- Hash
- Set
- Sorted Set

### 보조 자료형/기능
- 비트맵
- 지리적 공간 인덱스
- Pub/Sub
- HyperLogLog
- 레디스 스트림

### 레디스 유틸리티 명령어
- KEYS(성능이 좋지는 않음, SCAN계열 사용 권장)
- EXISTS(존재여부)
- TYPE(자료형과 기능 확인)
- DEL(키 삭제)

### String형

- 문자열, 이진 데이터, 정수, 부동소수점 등 저장 가능.
- 세션캐시 등 활용
- SET/GET, MSET,MGET 명령어 
- 숫자값 저장했을 경우 `INCR` 명령어로 증가 가능

|숫자값이 아닌 경우|시간복잡도|효과|
|----|----|---|
|GET|O(1)| 키 값 가져오기
|SET|O(1)| 키 값 저장하기
|MGET|O(N)| 여러 키 값 가져오기
|MSET|O(N)| 여러 키 값 저장하기
|APPEND|O(1)| 키에 값 덮어쓰기
|STRLEN|O(1)|키 값 문자열 길이 반환
|GETRANGE|O(N)| 범위 지정 값 가져오기
|SETRANGE|O(1)|범위 지정 값 저장하기

 
|숫자값인 경우|시간복잡도|효과|
|----|----|---|
|INCR|O(1)|값 1증가
|INCRBY|O(1)| 지정한 값 만큼 증가
|INCRBYFLOAT|O(1)| 부동소수점을 지정한 값만큼 증가
|DECR|O(1)|값 1감소
|DECRBY|O(1)|값 지정한 수만큼 감소

그 외 `GETEX`(초 단위 실행 값 가져옴), `GETDEL`(값 가져오고 지움), `MSETNX`(여러 값 저장 이미 키 존재시 실패) 등이 있다.

- `SET` 명령어 참고할만한 옵션
    - EX/PX 옵션: 만료시간 설정
    - NX/XX 옵션: 키 존재여부에 따라 조건을 충족할 때 저장
    - KEEPTTL: TTL을 변경하지 않고 조작
    - EXAT/PXAT: 유닉스 시간을 사용하여 유효시간 설정


### 리스트형

- LPUSH: 왼쪽에 값 넣기
- LRANGE: 지정한 숫자만큼 값 출력
- **보통 뉴스 토픽 같은 자주 접근해야하고 10개같이 고정된 값 등에 활용할 수 있음**

||시간복잡도|효과|
|----|----|---|
|LPOP|O(N)|리스트에서 n만큼 값을 가져오고 뺌.(왼쪽)
|LPUSH|O(N)|n만큼 값을 넣음
|RPOP|O(N)|리스트에서 n만큼 값을 가져오고 뺌.(오른쪽)
|RPUSH|O(N)|n만큼 값을 넣음
|LMPOP|O(N*M)| 리스트의 왼쪽 또는 오른쪽부터 여러 개의 값을 가져오고 삭제하기
|BLMPOP|O(N*M)| LMPOP과 비슷, 블록(block)이란 개념이 등장
|LINDEX|O(N)| 리스트에서 지정한 인덱스값 조회
|LINSERT|O(N)| 리스트에 지정한 인덱스 앞,뒤에 값 추가
|LLEN|(1)| 리스트 길이 조회
|LRANGE|O(S*N)| 리스트 범위 조회, S는 시작점또는 끝점에서 가장 가까운 거리
|LREM|O(N*M)| 리스트에서 지정한 수를 특정 값만큼 삭제
|LSET|O(N)| 특정 인덱스를 특정 값으로 수정
|LTRIM|O(1)| 지정한 범위의 인덱스의 리스트로 재갱신
|LPOS|O(N)| 지정한 탐색요소값의 인덱스를 반환

이 외, 리스트가 존재시에만 값넣기, 리스트 간 요소 옮기기, 블록기능이 있는 LPOP, RPOP 등이 있다.

### Hash형

- 하나의 해시에 저장할 수 있는 필드 갯수는 약 43억(메모리 여유가 있으면 사실상 무제한)
- 해시 각 필드는 별도 TTL 설정 불가능

||시간복잡도|효과|
|----|----|---|
|HDEL|O(N)| 지정한 필드 삭제
|HEXISTS|O(1)| 지정한 필드 존재 확인
|HGET|O(1)| 지정한 필드 값 가져오기
|HGETALL|O(N)|해시에 포함된 모든 쌍 가져옴.
|HKEYS|O(N)|해시에 저장된 모든 필드 가져옴.
|HLEN|O(1)|해시에 포함된 필드 수 가져오기
|HMSET|O(N)|필드에 값 저장. 덮어씌기 기능
|HSET|O(N)| Redis 4.0이후에는 HMSET과 같은 기능
|HVALS|O(N)|해시 필드의 모든 필드값 반환
|HSCAN|O(1)| 해시의 필드 집함을 반복 처리하여 필드 쌍 목록 반환

- 필드의 값이 숫자인 경우 `HINCRBY`, `HINCRBYFLOAT` 명령어로 값 증가 가능(O(1))
  

- HDEL, HKEYS같은 명령어는 필드 갯수에 비례하여 시간이 듦. SCAN을 사용하거나 설계를 다시 하는것도 고려해야함.


### Set형

||시간복잡도|효과|
|----|----|---|
|SADD|O(1)| 하나 이상의 멤버 추가
|SCARD|O(1)| 집합에 저장된 멤버수 반환
|SISMEMBER|O(1)| 멤버 포함 여부 확인
|SMEMBERS|O(N)| 집합에 포함된 모든 멤버 가져오기
|SPOP|O(1)| 집합에 포함된 무작위 멤버 가져오기
|SREM|O(1)|집합에서 하나 이상 멤버 삭제
|SSCAN|O(1)| 반복처리로 멤버 반환

외에 **집합간 차집합, 교집합, 합집합 등 연산이 존재**하는 것은 셋의 특징인 것 같다.


### Sorted Set형

- 순서가 있으니 랭킹, 활동 피드같은데서 쓰임

||시간복잡도|효과|
|----|----|---|
|ZADD|O(logN)| 지정한 점수와 멤버쌍 추가
|ZCARD|O(1)| 집합에 저장된 멤버 수 반환
|ZRANK|O(logN)| 오름차순으로 순위 추출
|ZREVRANK|O(logN)|멤버의 높은 순서대로 순위를 가져옴.
|ZRANGE|O(logN+M)| 점수 범위 밖에 있는 멤버 목록 오름차순으로 가져오기
|ZRANGESOTRE|log(N+M)|위와 동일하지만 지정한 키에 값 저장
|ZREM|O(MlogN)|지정한 멤버 삭제
|ZCOUNT|O(logN)| 지정한 점수 범위에 있는 멤버 수 반환
|ZPOPMAX|O(M*logN)|집합에서 점수가 최대인 멤버 삭제하고 가져오기
|ZPOPMIN|O(M*logN)|집합에서 점수가 최소인 멤버 삭제하고 가져오기
|ZSCORE|O(1)| 순서 집합에서 지정한 멤버 점수 가져오기
|ZMSCORE|O(N)|순서 집합에서 여러 멤버 점수 가져오기
|ZSCAN|O(N)| 순서 집합에서 반복처리하여 멤버 가져오기
|ZMPOP|O(K) + O(NlogN)| 집합에서 점수가 최대 혹은 최소인 여러 멤버를 삭제하고 가져오기(7.0.0 version 이상)
|BZMPOP|(O(K) + O(NlogN)| 블록 기능을 갖춘 ZMPOP

- Set과 마찬가지로 교집합, 차집합, 합집합 등의 연산이 존재

### 레디스 대표 기능, 명령어

- 비트맵
    - 사실상 string형
    - 메모리효율이 매우 높기에 on/off같은 기능을 나타내기에 적합하지만 사람이 보기 불편하여 디버깅이 어려움.
- 공간 인덱스
    - GEO~명령어로 데이터 조작가능
    - 내부적으로 Sorted Set 사용
- Pub/Sub기능
    - 채널 구독하여 이를 통하여 메시지 송수신 가능. Pub/Sub 구조는 많은데서 쓰이고 있으므로 딱히 설명 x
- HyperLogLog
    - 중복을 걸러야하는 방문자 뷰처럼 단순 카운팅값이 필요하다면 사용
        - 오차가 존재하기에 니즈가 정확한 값이 아닐때 사용하는게 나음
        - 키 값을 입력(?)하면 그냥 그 갯수가 증가함.
    - 메모리 효율이 높음.(약 12KB만 필요)
        - 키 값을 입력(?)하면 그냥 그 갯수가 증가함.
    - 메모리 효율이 높음.(약 12KB만 필요)
레디스는 여러 데이터를 저장할 때 내부적으로 인코딩을 수행함.
- String 형
    - int: 64bit 부호 정수
    - raw: 44byte 이상 문자열
    - embstr: 44byte 이하 문자열
- List
    - quicklist: 압축된 linkedList + ziplist
- hash
    - hashtable, list-pack
- set
    - intset: 모든 요소가 정수인 경우
    - hashtable
- Sorted set
    - listpack: 적을때
    - skiplist: 많을때
- HyperLogLog
    - Sparse: 특정 값보다 적을때
    - Dense: 많을때
- 공간 인덱스
    - 52bit Geohash
- 레디스 스트림
    - listpack


레디스는 여러 데이터를 저장할 때 내부적으로 인코딩을 수행함.


- String 형
    - int: 64bit 부호 정수
    - raw: 44byte 이상 문자열
    - embstr: 44byte 이하 문자열
- List
    - quicklist: 압축된 linkedList + ziplist
- hash
    - hashtable, list-pack
- set
    - intset: 모든 요소가 정수인 경우
    - hashtable
- Sorted set
    - listpack: 적을때
    - skiplist: 많을때
- HyperLogLog
    - Sparse: 특정 값보다 적을때
    - Dense: 많을때
- 공간 인덱스
    - 52bit Geohash
- 레디스 스트림
    - listpack

### redis stream

- 레디스 스트림은 스트림 작업에 사용되는 기능
    - pub/sub과 다르게 데이터 수신을 놓치지 않고 이력을 유지할 수 있음.
- 메시징 시스템 쿼리 모드가 존재
    - 스트림에 추가된 메시지와 같은 내용을 여러 Consumer에 전달할 수 있음.
- **엔트리** 개념이 나옴
    - 엔트리란 스트림에 추가되는 하나의 데이터 레코드 (로그 한 줄, 메시지 한 건)
- 다양한 명령어가 존재하지만 알아보지는 않을 것
    - XADD, XRANGE, XREVRANGE, XREAD, XLEN, XDEL, ...
- 레디스 7.0.0 이후에는 XADD 명령어 사용시 엔트리ID 자동생성
    - XTRIM, MAXLEN 옵션으로 엔트리 수에 제한을 걸 수 있음.
- Pub/Sub에 비하여 복잡하지만 그만큼 복잡한 기능이 필요하면 적용해보는 것도 검토하는게 나아보인다

### 자료형과 상관없는 명령어

- TTL관련

||시간복잡도|효과|
|----|----|---|
|EXISTS|O(N)| 하나 이상의 키 중 존재하는 키의 수
|TTL|O(1)|남은 TTL값을 초 단위로 반환
|PTTL|O(1)|남은 TTL값을 밀리초 단위로 반환
|EXPRIE|O(1)|TTL설정
|PEXPRIE|O(1)|TTL 밀리초 설정
|EXPIREAT|O(1)|TTL 유닉스 시간 설정
|PEXPIREAT|O(1)| TTL 유닉스 시간 및 밀리 초 단위 설정
|EXPIRETIME|O(1)| 키의 만료시간을 유닉스 타임스탬프 형식으로 표시
|PEXPIRETIME|O(1)|키의 만료시간 유닉스 타임스탬프 형식으로 표시
|PERSIST|O(1)|키의 지정된 TTL삭제

- 데이터 삭제 관련

||시간복잡도|효과|
|----|----|---|
|DEL|O(N)| 지정한 키 삭제
|UNLINK|O(1)|비동기 키 삭제
|FLUSHDB|O(N)|현재 데이터베이스 내 모든 키 삭제
|FLUSHALL|O(N)|모든 데이터베이스 내 모든 키 삭제

- 범용

||시간복잡도|효과|
|----|----|---|
|KEYS|O(N)| 키 목록 가져오기
|SCAN|O(1)| 현재 데이터베이스 내 키 목록을 반복 처리하여 가져옴
|DBSIZE|O(1)| 현재 데이터베이스 내 포함된 키 갯수 반환
|SORT|O(N+M*logM)| 지정한 기준으로 키 정렬
|SORT_RO|O(N+M*logM)| SORT + 읽기방식

- 싱글 스레드 기반이다보니 KEYS보다는 SCAN계열 명령어를 추천하고 COUNT 옵션을 통해 갯수를 줄여서 가져올 수 있다.
    - KEYS 명령어는 CPU 사용률이 높아지고, 레플리케이션 처리중 마스터와 레플리카 간의 접속이 끊어져서 다른 마스터에서 스냅숏을 가져오고 하는 등의 영향이 미칠 수 있기에 사용하지 않는 것을 추천


**Redis는 싱글쓰레드로 동작하기에 시간 복잡도를 잘 따져가면서 연산을 수행해야함.**





## 2장 후기

- 전체적인 자료구조를 알려주는건 좋았으나, 명령어 정리할땐 좀 지루했다. 그럴법도 한게 이런 명령어들은 어차피 잊기 마련인데 이런것들을 넘기기에는 또 애매하기 때문이다.
실질적인 레디스 운영법에 대한 학습을 원했다. 뒤에 나오겠지? 싶었다.

- 레디스 스트림에 대한 개념은 신기하기도 했고 흥미로웠다.
- 또한 중간중간에 운영체제적으로, 운영적으로 생각해야할 부분들을 언급해주었는데 그런 부분이 더 좋았다. KEYS를 잘 고려해서 사용해야한다 등..




