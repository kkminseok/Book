비기능적 요구사항이란

- 확장성
    - 하드웨어 리소스 사용을 쉽고 번거롭지 않게 조정할 수 있는 능력
- 가용성
    - 시스템이 요청을 수락하고 원하는 응답을 반환할 수 있는 시간의 백분율
- 성능/지연 시간, 처리량
    - 시스템이 응답을 반환하는 데 걸리는 시간, 시스템이 처리할 수 있는 최대 최대 요청 비율
- 내결함성
    - 일부 구성 요소가 실패해도 시스템이 계속 작동할 수 있는 능력
- 보안
    - 시스템 무단 접근 방지
- 프라이버시
    - 개인을 고유하게 식별하는 데 사용할 수 있는 개인 식별 정보
- 정확성
- 일관성
    - 모든 노드/서버의 데이터가 일치하는지 여부
- 비용
    - 트레이드오프 속성
- 복잡성, 유지보수성, 디버깅 가능성, 테스팅 가능성 
    - 시스템을 구축하고 구축 후 유지보수하는 것이 얼마나 어려운지 결정하는 개념

등을 다룬다.

책에서는 각 항목에 대해 상세히 설명하고 있지만 너무 당연한 애기는 나는 정리하지 않겠다.

## 1. 확장성

수직 스케일링 설명, 한계 및 단점에 대한 설명.

아무래도 호스트 1개로 업그레이드 하는 방식은 결국 물리적인 한계에 부딪힐 수 밖에 없다. 
다운타임도 존재하기에 보통 수평 스케일링을 통해 시스템을 확장한다.

데이터양, 초당 읽기 쿼리 수, 초당 비디오 조회 수 등을 통해 어떤 시스템으로 업그레이드할 지 정할 수 있다.

**4계층 로드밸런서 vs 7계층 로드 밸런서**

- 4계층 로드밸런서는 TCP계층에서 작동하고 처음 몇 패킷에서 주소 정보를 기반으로 라우팅 결정을 내린다.
- 7계층 로드밸런서는 HTTP계층에서 동작하므로 다음과 같은 기능이 존재한다.
    - 인증: 지정된 인증 헤더가 없으면 401 반환
    - TLS 종료: HTTPS -> HTTP변환을 통해 전달하여 암호화/복호화 비용을 줄일 수 있다.

**로드 밸런싱 vs 리버스 프록시**

로드 밸런싱은 확장성을 위한 것. 리버스 프록시는 클라이언트-서버 통신을 관리하기 위한 기술.


## 2. 가용성

CAP정리를 참조하여 가용성을 높이기 위해 무엇을 트레이드오프할 수 있는지 논의가 필요하다.

즉각적인 응답이 필요하면, 동기식 프로토콜을 사용한다. 응답을 즉시 반환할 필요가 없는 서비스는 비동기 프로토콜을 사용하는 것도 방법이다.

## 3. 내결함성

내결함성을 위한 대표적인 기법은 다음과 같다.

- 복제와 중복
    - 같은 구성요소를 지닌 인스턴스/복사본을 3개 이상 가지는 것. 최대 2개가 다운되어도 1개는 정상 동작할 수 있게끔 한다.
    - 대표적인것은 `하둡` 분산 파일 시스템
- 서킷 브레이커
    - 클라이언트가 실패할 가능성이 높은 작업을 반복적으로 시도하는 것을 막는 메커니즘
    - 과부하 상태인 시스템에 클라이언트가 과하게 부담을 주는 것을 방지.
    - 전체적인 시스템 테스트를 어렵게할 가능성이 있음. 다운스트림을 막기에 그 부분에서 응답시간이 제 시간에 왔다고 판단할 수 있기 때문
    - 대표적인 것은 `Resilience4j`
- 지수 백오프와 재시도
    - 요청을 재시도하기 전에 대기하고 재시도 사이의 대기 시간을 지수적으로 증가시킴.
    - 목적은 '재시도 폭풍'을 방지.
- 다른 서비스의 응답 캐싱  
    - 기본 값이나 빈 응답을 제공하는 경우도 있다. 만약 외부 서비스의 데이터가 자주 변경되지 않는 것이라면 캐싱해서 사용할 수도 있다.
- 데드 레터 큐(DLQ)
    - 서드파티 API 쓰기 요청 실패시 데드 레터 큐에 넣고 나중에 다시 시도한다.
- 로깅과 주기적 검사
- 벌크헤드
    - 시스템을 격리된 풀로 나눠 한 풀(Pool)의 결함이 전체 시스템에 영향을 미치지 않게 함.
    - API마다 자체 스레드풀을 가져서 엔드포인트의 스레드 풀이 소진되더라도 다른 엔드포인트가 요청 처리 못하는 일은 벌어나지 않음.
- 폴백 패턴
    - 문제를 탐지한 다음 대체 코드 경로를 실행하는 것으로 구성. 
    - 예를 들어서 응답에 문제가 생긴 경우 캐싱된 데이터를 반환한다. 사용자에게 오류를 뿜는 것보다 더 나은 경험을 제공할 수 있다면 이 방법을 고려할 수 있다.
    - **폴백의 신뢰성과 폴백 자체가 실패할 수 있다는 점을 고려해야한다.**

## 4. 성능/지연 시간과 처리량

낮은 지연 시간을 달성하려면 사용자와 가까운 데이터 센터에 서비스를 배포하거나, CDN 사용, REST대신 RPC로 데이터 줄이기, 네티와 같은 프레임워크를 사용해서 HTTP대신 TCP, UDP, 스트리밍 사용 등이 있다.

## 5. 일관성

일관성에 대해 논의할 때에는 ACID, CAP 일관성의 차이 및 선형화 가능성과 일관성 사이의 트레이드오프를 강조해야한다.

선형화 가능성의 단점은 대부분 노드나 모든 노드가 요청을 처리하기 전에 합의를 거쳐야하므로 가용성이 낮아질 수 있다. 그리고 복잡성 또한 증대해진다.

선형화 가능성과 최종 일관성을 위한 다양한 기법은 다음과 같다.

### 1. 전체 메시

- 클러스터가 모든 호스트의 주소를 가지고 모든 호스트에 메시지를 브로드 캐스트함.
- 구현인 쉬우나 확장성은 없다. 메시지 수는 호스트 수에 따라 증가한다. 
•	노드 수가 많아질수록 연결 수가 기하급수적으로 증가
(연결 수 = N*(N-1)/2).
→ 10대면 45개, 100대면 4950개 연결이 필요.


### 2. 조정 서비스

- 리더를 하나 둬서 리더 집합을 관리한다. 다른 모든 노드는 리더에게 메시지를 보내고, 리더가 이를 가지고 필요한 처리를 수행한 후 최종 결과를 다시 보낸다.
- 대표적인 것은 `Raft` 
- 단점은 복잡성이 있다. 오직 하나만의 리더를 선출해야하는 정교성이 필요하다. 만약 두 노드 이상이 자신이 리더라고 믿는 경우 이를 '스플릿 브레인'이라고 한다

### 3. 분산 캐시

- 레디스나 Memcached와 같은 분산 캐시를 사용하는 방법
- 다만 레디스는 암호화를 지원하지 않아 프라이버시 문제가 있을 수 있다. 저장시 암호화를 구현하면 복장서과 비용이 증가하여 성능저하가 발생한다.

### 4. 가십 프로토콜
- 클러스터내 각 노드는 주기적 또는 무작위 간격으로 다른 노드를 무작위로 선택하여 데이터를 공유한다.
- 대표적으로 카산드라는 분산 데이터 파티션 전체의 일관성을 위해 가십 프로토콜을 사용한다. 

### 5. 무작위 리더 선택
- 알고리즘 자체는 단순한데, 오직 하나의 리더만을 보장하지 않을 수 있다. 모든 리더 포함 모든 호스트가 동일 데이터를 가지는 형태가 될 수 있다.
- 단점은 중복 요청과 불필요한 네트워크 트래픽이 발생할 수 있다는 것.

## 6. 정확성

- 데이터의 정확성은 데이터 값이 정확하고 근사치가 아님을 의미
- 추정 알고리즘은 더 낮은 복잡성을 위해 정확성을 트레이드오프
- 캐시의 데이터가 오래되어 정확성이 낮아진 경우, 주기적으로 데이터를 가져오도록 설계하는 방식이 있으나 비용이 더 많이 든다. 그렇다해서 데이터가 수정될 때마다 캐시를 업데이트하거나 삭제하는 것은 시스템의 복잡성을 증대시킨다.
- 정확성은 일관성과 관련이 깊은데, 정확성을 높이면 일관성이 떨어질 수 있기 때문이다. 복제본에도 정확성을 위해 쓰기 작업을 하는 동안은 일관성이 떨어질 수 있기에 이런 부분에 있어서 트레이드오프가 있다.

## 7. 복장성과 유지보수성

- 복잡성을 최소화 하는 첫 단계는 기능적 요구사항과 비기능적 요구사항을 모두 명확히 하는 것.
- 복잡성을 줄이고 요지보수성을 개선하려면 다양한 서비스에 적용 가능한 공통 서비스를 적극 활용하자.
    - 로드밸런서 서비스
    - 속도 제한 방식
    - 인증과 인가
    - 로깅, 모니터링, 알림
    - TLS 종료
    - 캐싱
    - CI/CD

- 복잡성은 가용성과 내결함성과 연관이 있다. 가용성과 내결함성을 높이려면 복잡성이 증대해질 수 있다. 때문에 복잡성을 낮추려면 가용성과 내결함성을 희생해야할 수 있다.

## 8. 비용

비용을 낮추기 위한 얘기.. 과도한 모니터링 알림 구현 자제, 라이브러리 종속성때문에 버전 업그레이드에 관한 이야기 등에 대한 이야기

## 9. 보안

- DDoS 공격을 방지하기 위한 속도 제한 방식, OAuth 2.0, OpenID Connect에 대한 고려, 이해 필요

## 10. 프라이버시

- 사용자를 식별하는 데이터. 이름, 주소, 이메일 등을 말함. 
- 정책을 잘 가지고 보안에 신경 쓰자

## 11. 클라우드 네이티브

- 사실 이 책에서 설명하고 있는 기법들(컨테이너, 서비스 메시, 마이크로서비스, 서버리스 함수, 자동화 등)이 클라우드 네이티브를 지향하는 방법들이라고 생각하면 될 것 같다.


------


## 총평

서비스를 설계하는데 중요한 원칙들에 대해 다루었다. 글을 읽으면서 클라우드 네이티브 지향과 비슷하다고 생각했는데 아니나 다를까 마지막에는 클라우드 네이티브를 언급하여 마무리하였다.

글 내용은 좋았다. 궁금한 키워드들은 직접 찾아보면 될 것 같다. 

