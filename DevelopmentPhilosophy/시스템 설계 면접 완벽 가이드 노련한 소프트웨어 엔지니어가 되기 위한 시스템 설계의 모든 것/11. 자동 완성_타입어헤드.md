자동 완성은 지속적으로 대량의 데이터를 수집하고 처리해 특정 목적으로 사용자가 쿼리할 수 있는 작은(수 MB) 데이터 구조로 만드는 분산 시스템을 설계하는 능력을 테스트할 수 있는 질문이다.

검색과 자동 완성의 차이점을 책에서 다루고 있다.

검색|자동 완성|
-----|-----|
몇 초의 지연시간이 허용될 수 있다.|우수한 사용자 경험을 위해 낮은 지연시간이 필요하다.|
문자열, 복잡한 객체, 파일이나 미디어를 포함한 다양한 결과 데이터 유형이 가능하다.|항상 문자열 데이터를 반환한다.|
각 결과에 관련성 점수가 부여된다.|항상 관련성 점수가 있는 것은 아니다.|
정확도인 관련성 점수를 가능한한 정확하게 계산하기 위해 노력을 많이 기울인다.|정확도 요구사항이 검색만큼 엄격하지 않을 수 있다.|
검색 결과는 입력 문서 중 어느것이든 반환할 수 있다. 모든 문서를 처리하고, 색인화하고, 검새 결과로 반환할 수 있어야 함을 의미한다.| 높은 정확도가 필요하지 않으면 복잡성을 낮추기 위해 샘플링과 근사 알고리즘과 같은 기술을 사용할 수 있다.|
수백 개의 결과를 반환할 수 있다.|일반적으로 5~10개의 결과를 반환한다.|

여러 가지 기능적 요구사항이 존재하는데, 알 법한 것은 제외하고 책에서 언급한 모르던 것들을 정리한다.

- 사용자 검색기반이 아닌, 이를 포함하여 데이터베이스에 저장되어있는 소스를 이용해서 제안할 수 있는 기능이 있을 수 있다.
- 위의 제안에 기간이 고려될 수 있다.
- 부적절한 제안을 신고할 수 있는 기능이 있을 수 있고,메커니즘에 대해 고려할 수 있다.


비기능적 요구사항은 다음과 같을 수 있겠다.

- 글로벌 사용자 기반이 사용할 수 있게 확장이 가능해야 한다.
- 높은 가용성은 필요하지 않다. 
- 높은 성능과 처리량이 필요하다.
- 일관성은 필요하지 않다. 추천이 몇 시간 전의 데이터여도 괜찮고, 새로운 추천 항목이 바로 추가되지 않아도 괜찮다.
- 정확도 관련해서는 처음에는 정확하지 않아도 점차 시간이 지나면서 개선될 수 있어야할 것 같다. 

책에서는 초기 아키텍처를 사용자, 수집시스템, 데이터베이스, 쿼리 시스템 네 개를 두었다.

사용자는 검색 쿼리를 제출하면 수집 시스템이 이를 처리한 후 데이터베이스에 저장한다. 사용자는 검색 문자열을 입력할 때 데이터베이스에서 자동 완성 제안을 받는다.
때문에 위 시스템은 다음과 같은 구성요소로 나눌 수 있다.

1. 데이터 수집
2. 데이터 처리
3. 처리된 데이터를 쿼리해 자동 완성 추천을 얻는다.

데이터 처리는 리소스 집약적이라 따로 두었다고 한다. CQRS설계 패턴의 예시이다.

-----

자동완성을 처리하는 알고리즘은 가중치 트라이(Trie)가 있을 수 있다. 특정 단어를 문자로 쪼개서 각 문자에 가중치를 메긴 트리를 구성하는 것이다.

가중치가 높은 것을 우선적으로 상위로 분류해서 반환한다.

책에서는 스파크, 하이브, 엘라스틱서치를 사용해서 구현한다고 한다. 스파크와 하이브는 엘라스틱서치에 통합하기 쉽다고 한다.


-----

부적절한 단어를 분류하기 위해서 책에서는 단어 서비스라는 별도의 서비스 아키텍처를 구축했다.

이는 정렬된 적절한 단어나 부적절한 단어 목록을 반환하는 API 엔드포인트를 가진다. UI -> 백엔드 -> SQL로 이루어져있고, 데이터베이스는 단어용 문자열 열과 단어가 테이블에 추가된 타임스탬프, 이 단어를 추가한 사용자, 그리고 단어가 적절한 부적절한 이유가 담긴 열 등으로 이루어질 수 있다.

퍼지매칭 알고리즘을 통해서 사용자의 철자 오류를 수정하고 원래 문자열이나 퍼지 매칭된 문자열을 반환하는 함수를 코딩할 수 있다.

신조어같이 잘 알려지지 않은 단어에 대해서는 별도 테이블에서 관리하도록 설계할 수 있다. 그 다음 UI를 제공해서 관리자 적절한 단어나 부적절한 단어에 추가하도록 할 수 있다.

자동 완성에 높은 정확도가 필요하지 않으면 샘플링 해야 한다. 

사용자가 입력한 내용을 로그 테이블에 적재하려면 엄청 많은 데이터가 적재될 수 있다. 이 때문에 샘플링 통해 10%만 저장한다거나 로깅 보존 기간을 줄이는 등의 방법이 있다.

-----

만약 단일 단어가아닌 구문을 처리하게 된다면 어떻게 설계해야하는가?

자동 완성 추천의 최대 길이를 정해야한다. 최대 길이가 길수록 사용자 경험은 좋아지겠지만 비용과 성능의 트레이드오프가 필요하다. 
언어 마다 문화와 특성이 다르기에 고정길이로 하긴 어렵다. 사용자 검색 문자열 길이의 백분위를 정하거나 하는 등으로 정할 수도 있다. 

구문에 부적절한 단어가 있다면 어떻게 해야할까? 구문에 부적절한 단어가 하나라도 포함돼 있으면 전체 구문을 필터링하거나, 필터링 하지 않고 보여주는다. 단어를 필터링을 할 수는 있지만 구문을 필터링하는 것은 어렵다 한다.
현재의 해결책은 머신러닝과 조합하는 것이다.

## 총평

단어 시스템 설계를 보면서 느낀 것은 어떻게 단계적으로 확인해야하는지는 알겠다.

기능적 요구사항, 비기능적 요구사항을 정하고 간단한 아키텍처를 설계한 뒤, 차근차근히 넓혀나가는 것이다.

그리고 어떻게 보면 간단한 기능을 가진 서비스가 이렇게 아키텍처가 커지는 것을 보고, 왜 큰 기업에서는 그런 전문팀이 따로 있는지 알 것 같더라.

