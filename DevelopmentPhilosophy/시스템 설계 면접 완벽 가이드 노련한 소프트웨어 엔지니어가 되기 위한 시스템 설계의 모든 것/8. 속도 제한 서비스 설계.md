속도 제한은 소비자가 API 엔드포인트에 요청할 수 있는 속도를 정의. 봇과 같은 클라이언트의 의도하지 않은 악의적인 과도한 사용 방지

DOS, 무차별 대입 공격, 웹 스크래핑을 방지할 수 있다.

- DOS: 트래픽을 폭증 시켜 정상 트래픽을 처리할 수 없게 함.
- 무차별 대입 공격: 비밀번호, 암호화 키 등을 랜덤한 값을 계속 투입해 공격하는 방식
- 웹 스크래핑: 봇을 사용해 웹 애플리케이션의 많은 웹 페이지에 GET 요청을 보내 대량 데이터를 얻는 방법.

속도 제한은 라이브러리, 프론트엔드, API 게이트웨이, 서비스 메시 등으로 제어가 가능하다.

## 속도 제한 서비스의 대안과 실현 불가능의 이유

이 작은 챕터는 나름 고민할 것이 많아 보여서 정리해야겠다고 생각했다.

트래픽이 급증할 때 이를 처리하기 위해서 새 호스트를 추가하는 과정 자체가 느릴 수 있다. 새 호스트 추가에는 도커 컨테이너 다운로드, 서비스 시작, 
새 호스트로 로드밸런서 구성 업데이트 등 거쳐야하는 단계가 많다. 호스트를 늘려서 급증한 트래픽을 처리하는 것은 악의적인 요청도 같이 처리해버린다.

악의적인 요청을 처리해서는 안 되는데, 보통 429 Too Many Requests를 반환하지만 이에 대해서 특별한 2가지 옵션을 두고 처리할 수 있다.

1. 요청을 버리고 응답을 반환하지 않아 공격자가 서비스에 장애가 발생했다고 생각하게끔 한다.
2. 사용자를 섀도우 밴해서 200을 반한하되, 빈 응답이나 오해의 소지가 있는 응답을 보내게 한다.

속도 제한은 보통 별도의 서비스에서 제한거는데, 그 이유는 각 호스트가 관리하면 다른 요청해야할 것들에 부담을 줄 수도 있기 떄문이다.

속도제한을 하는 다른 방법 중 하나는 로드밸런서를 사용하는 것이다. 4계층 로드밸런서는 요청의 내용을 처리할 수 없기에, 7계층 로드밸런서를 속도제한 때문에 사용하는 것은 너무 과할 수 있다. 이런 경우 따로 서비스로 빼는게 더 나은 해결책일 수 있다.

속도 제한을 걸 때에는 잘 판단해야한다. 특정 요청에 대해서는 속도 제한이 오히려 불편한 사용자 경험을 제공할 수 있다.

속도 제한 서비스는 확장이 가능해야하고, 속도 제한 서비스는 서비스를 처리하기 전에 전치리 과정을 거치므로 어느정도 성능이 보장되어야하며, 기능을 명확히 하여 복잡성을 낮춰야하고,
보안 프라이버시는 속도 제한 서비스로는 부족할 수 있어서 따로 구현해야한다. 가용성과 내결함성은 필요하지 않을 수도 있다. 그 이유는 결국 가용성을 포기하는 서비스기 때문이다. 
사용자 경험 저하를 방지하려면 과도한 클라이언트를 잘못 식별해 속도를 제한해서는 안 된다. 일관성은 보장되지 않아도 된다. 속도 제한 정책이 변경된다해서 바로 적용될 필요는 없다.

사용자의 속도 제한을 디스크에서 읽는 것을 최소화하기 위해 사용자ID, 서비스ID를 캐싱해서 사용하는 방법이 있다. 캐시에 보통 60초 TTL을 건다.

속도제한 서비스를 설계할 때 사용자에대한 카운트 정보를 저장하는 방식에 3개가 있다. 이는 모두 트레이드오프가 존재한다.

상태 비저장 백엔드 설계| 상태 저장 백엔드 설계| 모든 호스트에 카운트 저장|
------|-----|-----|
분산 데이터베이스 카운트 저장| 각 사용자의 카운트를 백엔드 호스트에 저장| 모든 사용자의 카운트를 모든 호스트에 저장|
상태 비버장으로 사용자를 어떤 호스트로 라우팅 가능| 7계층 로드밸런서 사용으로 라우팅 필요| 모든 호스트가 카운트를 알기에 어떤 호스트로 라우팅 가능|
확장 가능. 높은 읽기/쓰기 트래픽 처리| 확장 가능 수직 확장.| 확장 불가능. 모든 호스트가 카운트 값을 저장해놓고 있어야하기 때문에|
효율적인 저장소 사용 가능| 백업이 존재하지 않아서 낮은 저장소 사용량, 가장 저렴| 비용이 가장 많이 드는 접근법. 모든 호스트가 알고 있어야하므로|
최종 일관성, 동기화 완료 전 속도 제한 결정 시 약간 부정확할 가능성 존재| 사용자가 항상 같은 호스트에 요청하기에 일관적| 카운트 동기화 때문에 일관성이 낮음|
분산 데이터베이스의 고가용성/내결함성| 가장 낮은 가용성/내결함성| 가장 높은 고가용성/내결함성|
외부 데이터베이스 서비스에 의존| 의존성은 없지만 로드밸런서가 모든 요청을 처리해야함. 핫샤드 방지 필요| 의존성 없음. 서비스 중단 위험성 피할 수 있음. 하지만 이를 변경할 때에는 많은 비용이 필요함.

-----

카운트 동기화할 때 어떠헥 해야할까?

동기화 메커니즘은 푸시여야할까? 풀이여할까? 푸시인 경우 일관성과 정확성을 양보하는 대신 더 높은 성능과 낮은 리소스 소비, 낮은 복잡도를 가진다.

### 전체 대 전체(All-to-all)

이는 그룹 내의 모든 노드가 다른 모든 노드에 메시지를 전송하는 것을 의미한다. **브로드캐스팅**방식이라고 할 수 있다.
당연하겠지만 비용이 많이 든다.

### 가십 프로토콜(Gossip protocol)

노드는 주기적으로 무작위로 다른 노드를 선택해 메시지를 보낸다. 일관성과 정확성을 낮춰 더 높은 성능과 낮은 리소스 소비를 얻을 수 있다.

전체 대 전체나 가십 프로토콜은 각 노드의 IP를 알고 있어야한다. 떄문에 노드가 추가되거나 삭제될 때 관리를 해야한다. 이런한 요구사항이 있으면 주키퍼와 같은 구성 서비스에 요청을 보내야할 수도 있다.

### 외부 저장소와 조정 서비스

중앙 집중 관리식 처럼 외부 스토리지/조정 서비스를 관리하는 하나의 서비스를 통해 통신할 수 있다. 각 호스트는 리더 호스트이 IP만 면 되고, 리더 호스트는 주기적으로 호스트 목록을 업데이트 하면 된다.

### 무작위 리더 선출

리더를 선출하는 간단한 알고리즘을 사용해 복잡성을 낮추는 대신 더 높은 리소스 소비를 택할 수 있다.
다만 Split Brain문제가 발생할 수 있다.

-----

속도 제한 알고리즘에는 어떤것들이 있을까?

10초 동안 10개의 요청이 온다고 가정하자.

- 토큰 버킷
    - 최대 토큰 수, 현재 사용 가능한 토큰 수, 버킷에 토큰이 추가되는 보충 속도 3가지 특성을 가진다.
    - 요청이 도착할 때마다 버킷에서 토큰 하나씩 제거하고, 토큰이 없으면 요청이 거부되는 알고리즘이다. 일정한 속도로 버킷에 토큰이 보충된다.
    - 이해하고 구현하기 쉽고 메모리 효율적. 다만 토큰을 보충할 때 해시 맵에 값을 증가하는 방식에 있어서 리소스 오버헤드와 네트워크 지연을 초래할 수 있다.
- 누수 버킷
    - 최대 토큰 수가 있고, 고정 속도로 누수되며, 비어 있을 때 누수가 멈춤. 요청이 도착할 때마다 버킷에 토큰을 추가함. 버킷이 가득차면 요청이 거부되거나 속도가 제한되는 알고리즘.
    - FIFO큐룰 사용 큐는 주기적으로 Deque되며, 요청이 도착하면 Enque되는 방식.
    - 토큰 버킷보다는 메모리 효율성이 낮다.
    - 매초 호스트는 모든 키의 모든 큐를 디큐해야하고, 오래된 키를 삭제하느 별도 메커니즘이 필요하며, 분산환경에서 동기화 되기 전에 버킷/큐를 채워버릴 수 있다는 단점이 있다.
- 고정 윈도우 카운터
    - 키-값 쌍으로 구현되는데 키는 클라이언트ID와 타임스탬프의 조합일 수도 있고, 값은 요청 횟수이다.
    - 사용자가 요청보낼 때 해당 키의 값이 설정된 속도 제한 내에 있으면 요청이 수락되고 설정된 속도 제한을 초과하면 거부된다.
    - 예를 들어서 user0_1628825241키는 GMT 3:27:00 AM을 나타내는데 이 값에 들어온(~ 3:27:59)까지 요청은 유효하다고 판단하는 것이다.
    - 단점은 속도 제한이 최대 2배까지 요청 속도를 허용할 수 있다는 것이다. 경계값 근처에서 요청을 진행하다보면 속도 제한에 맞지 않게 요청이 허용될 수 잇다.
    - 키를 특정 시간 뒤에 만료시키도록 설정해야하는데, 별도의 프로세스를 만들어서 해결할 수도 있다.
- 슬라이딩 윈도우 로그
    - 키는 클라이언트ID이고, 값은 정렬된 타임스탬프 목록을 가지는 맵을 구성한다. 각 요청 타임스탬프를 저장한다. 
    - 새로운 요청이 들어올 때 마다 첫 번째 타임스탬프가 만료되었는지 확인하고, 만료되었다면 이진검색을 통해 만료된 값을 모두 제거 시켜준다. 이진 검색 때문에 리스트를 사용해야하며, 리스트에서 10개 이상의 타임스탬프가 있으면 요청을 제한한다.
    - 이러한 방식의 장점은 분산 환경에서는 예외는 있지만 정확하다는것이다. 그리고 요청때마다 타임스탬프를 저장하므로 리소스 소비가 크다는 것이다.
- 슬라이딩 윈도우 카운터
    - 고정 윈도우 카운터와 슬라이딩 윈도우 로그를 발전시킨 것이다. 여러 개의 고정 윈도우 간격을 사용한다. 각 간격은 속도 제한 시간 윈도우의 1/60이다.
        - 속도 제한 간격이 1시간이라면 1시간자리 윈도우 하나 대신 1분짜리 윈도 60개를 사용한다.

-----

속도 제한에는 로깅, 모니터링, 경보를 구축해서 다음과 같은 정보들을 얻어야한다.

- 섀도우 밴을 당했음에도 불구하고 계속해서 높은 비율로 요청을 보내는 사용자 확인
- 짧은 시간 내에 비정상적으로 많은 수의 사용자가 속도 제한을 받는 것과 같은 잠재적 DDoS 시도의 징후

-----

## 총평

속도제한쪽은 중요하다면 중요한 부분으로 알고 있다. 
현재 다니고 있는 회사에 대입하자면 속도제한을 필요로 할만큼 크지도 않고 사용자들에게 알려져 있지도 않다. 만약 규모가 크고, 서비스를 많은 사용자가 이용한다면 속도 제한 서비스는 필수 불가결일 것 같다.

회사 내에서도 이에 대한 필요성은 인지하고 있으므로 추가를 원하다면 추가를 하지 않을까 한다.

내용자체는 잘 풀어서 설명해준 것 같아서 좋았다.