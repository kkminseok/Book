크레이그리스트, 책에서 말하는 임의의 애플리케이션이다.

분류 광고 게시물을 위한 웹 애플리케이션이며, 10억 명이 넘는 사용자를 보유할 수 있다. 

모닐리스 아키텍처를 고려한 시스템 설계를 고려한 장이라고 하니, 참고하면 될 듯하다.

## 1. 요구사항

- 두 가지 사용자가 존재한다. 조회자와 게시자.
- 게시자는 게시글을 쓸 수 있다.
    - 제목
    - 설명 문단 몇 개
    - 가격, 단일 통화를 가정
    - 위치
    - 최대 10장의 사진(각 1MB)
    - 동영상, 애플리케이션 추후 버전에 추가 가능
- 조회자는 다음 요구사항이 존재한다.
    - 지난 7일 동안 특정 도시에서 작성된 모든 게시글을 보거나 검색한다. 무한 스크롤
    - 결과에 필터 적용 가능
    - 개별 게시물을 클릭해 세부 정보 볼 수 있다.
    - 이메일 등으로 게시자에 연락 가능하다.
    - 게시글 신고 기능이 있다.
- 비기능적 요구사항
    - 확장성: 단일 도시에서 최대 1,000만명의 사용자 수용
    - 높은 가용성: 99.99% 가동시간
    - 높은 성능: 조회자가 게시글을 작성 후 몇 초 내에 볼 수 있어야 한다.
    - 보안: 게시글 작성 전 로그인 필수. 

저장공간 대부분은 크레이그리스트 게시물용, 때문에 저장공간이 많이 필요하지는 않다. 이는 단일 호스트로도 충분하고, 분산 스토리지가 필요 없다.

## 2. API

- 게시글
    - 게시글 GET/PUT/DELETE
    - /search
    - /contact
    - /report
    - DELETE /old_posts
- 사용자 관리
    - /signup
    - /login
    - DELETE user

## 3. 스키마 설계

SQL을 설명하고 있는데, 여기에 따로 적지는 않겠다.

## 4.초기 고수준 아키텍처

사용자 인증 서비스와 객체 스토리지를 사용하는 모놀리스

모니터링, 알림, 로깅 서비스 추가

## 5. 모놀리스 아키텍처

면접할 때 모놀리스로 짰다는걸 두려워하지말라. 잘 설명해라라는 챕터인듯함.

전체 웹페이지를 객체 스토리지에 저장해서 사용한다는데, 이에 대한 트레이드오프는 네비게이션바 같은게 모든 게시물에서 중복된다는 것이다.

## 6. SQL 데이터베이스와 객체 스토리지 사용

객체스토리지는 이미지 파일을 넣고, SQL 데이터베이스는 게시물에 대한 정보를 저장한다.

클라이언트가 백엔드 호스트를 통해 이미지를 다운로드 받으면 백엔드 호스트에 추가적인 부담을 주고,이미지 다운로드 지연 시간을 증가시킨다.

이미지의 크기가 크지 않다면 image blob열을 가져서 데이터베이스에 저장할 수도 있다.

## 7. 마이그레이션은 번거롭다.

데이터베이스에 이미지를 저장하면 마이그레이션시 까다롭다는 단점이 있다.
로컬에 개발자가 python으로 마이그레이션 스크립트를 작성할 수도 있다. 작성할 떄는 네트워크 이슈 등으로 마이그레이션 도중 실패할 수 있음을 알고 있어야한다.
스크립트 작성 자체가 문제가 있을 수 있으므로 로깅은 필수이다.

쓰기에 대한 멱등성을 지녀야한다.

속도가 너무 오래걸리면 데이터 센터 내에서 스크립트를 실행해야한다. 

마이그레이션자체가 너무 비용이 많이 들기에 마이그레이션을 가능하면 피해야 한다. 

## 8. 게시글 작성과 읽기

게시글을 등록할 때 이미지를 첨부하려면 병렬적으로 이미지를 첨부하거나 동기적으로 첨부하는 방식이 있다.

전자의 경우 이미지가 제대로 첨부 되었는 지 확인이 어렵지만 빠르고, 후자의 경우는 파일의 크기에 따라 응답이 느려진다는 단점이 있다.

두 가지 방법의 트레이드오프는 무엇인가?

- 백엔드 제외 방식: 적은 리소스와 전반적인 지연 시간 감소
- 백엔드 포함 방식: 객체 스토리지에 인증 절차를 포함할 필요가 없음. 네트워크가 외부에 노출되지 않아서 공격 대상의 축소 이점이 있음, 조회자가 게시글의 모든 이미지를 볼 수 있음이 보장됨.

보통 클라이언트가 이미지 파일을 백엔드에 쓰지만 CDN에서 이를 읽는 방식을 사용한다고 한다.

## 9. 기능적 분할

사용자의 지리적 위치에서 가까운 데이터센터로 요청을 보내는 것을 의미. 

## 10. 캐싱

시장 가치보다 훨씬 저렴한 가격의 물품을 소개하는 게시물처럼 조회가 잦은 것들에 대해서는 캐시 방식을 사용할 수 있다. 

## 11. CDN

만약 정적파일이 크다면 CDN을 사용하는 것을 고려할 수 있다.

## 12. SQL 클러스터로 읽기 확장

읽기 작업의 확장이 필요하다면 SQL복제를 사용을 고려해볼 수 있다.

## 13. 쓰기 처리량 확장

수평확장과 카프카의 같은 메시지 브로커를 사용해서 어느정도 해소가 가능하지만 아키텍처가 복잡해짐에 따라 최종 일관성 보장이 어려울 수 있다.

더 높은 쓰기 처리량이 필요하다면 카산드라나 HDFS가 있는 카프카와 같은 NoSQL 데이터베이스 쓰는 것도 고려해볼 법 하다.

## 14. 이메일 서비스

다음 장에서 설명

## 15. 검색

엘라스틱 서치 사용, 인덱스 생성 방식 논의

## 16. 오래된 게시물 제거되지

크론 작업이나 에어플로를 사용. 간단하고 중요도는 낮지만 실수를 하지 않도록 조심해야한다.

## 17. 모니터링과 알림

배치실패, 특정 용어의 높은 검색 수, 신고가 많은 게시물 등 이상 감지를 하는 모니터링과 알림 구축이 필요하다.

-----

뒤에는 면접에서 요구할만한 추가 요구사항에 대한 이야기와 어떻게 대답해야할지 가이드라인을 제공하고 있다.

이는 따로 정리하지 않겠다.

## 총평

가정이 10억명 수용한 서버를 만들고 그에 따라서 고려해야할 사항에 대해 논의하였는데, 두 가지 생각이 들었다.

첫 번째 생각은 10억명이 크게 중요하지 않을 수 있다.? 주어진 자원안에서 어떻게 활용해야할지 고민하는건 10억면이거나 100억명이나 다 동일하다고 생각이 들었다.

1명 1명이 트래픽이라고 생각하면 꾸준히 10억개의 트래픽이 들어오고, 이를 어떻게 분산처리할 지 고민하는 과정이 필요한 것 같다.

두 번째 생각은 뭔가 명확한 해결방법은 없다는 것이다. 트레이드 오프가 다 있고, 나름의 계산을 통해서 시스템에 맞게 설계해야하는 것 같다는 생각을 하였다.