무엇을 설계할 것인지, 그 범위를 정해야한다.

애플리케이션, 미들웨어, 데이터베이스, OS, 하드웨어, 네트워크 등 어디까지 설계할 것인가?

또한, **마이그레이션 설계**도 고려해야한다.
이후에는 모니터링, 장애조치 등을 포함한 **운영 설계**도 생각해야한다.

책에서는 다양한 개발 프로세스를 설명하고 있다.

- 워터폴: 프로세스가 각 단계별로 존재. 해당 단계가 마무리 되지 않으면 다음 단계는 실행되지 않는 단점.
- 점진적: 사이클을 가지며, 해당 사이클마다 다른 부분을 개발하는 방식
- 애자일: 기존 것들을 수정하면서 다른 부분도 개발하며 품질을 올리는 방식

-----

## 설계의 목적

- 요구사항 정의 내용을 시스템에서 어떻게 구현할지 검토 -> 다음 단계인 프로그래밍을 위해
- 요구사항 정의에서 드러나지 않은 시스템 기능 검토 -> 이전 요구사항 정의의 연속성을 위해
- 프로젝트 이해관계자 간 정보 공유 -> 개발 프로젝트 운영을 위해
- 시스템 풀질 향상 -> 다음 단계인 프로그래밍을 위해
- 유지보수를 위해 설계 정보 기록 -> 개발 후 유지보수를 위해

설계의 종류에는 **내부 설계, 외부 설계, 아키텍처 설계** 등이 있다.

- 외부설계: 사용자나 외부 시스템에 제공하는 기능이나 인터페이스(화면 설꼐, 배치 설계, 데이터베이스 논리 설계 등)
- 내부설계: 외부 설계에서 정해진 입력과 출력 사이에서 이루어지는 내부 처리를 구현(화면 프로그램 설계, 물리 디비, 데이터베이스 프로그램 설계 등)

- 플로차트: 일련의 처리를 시작부터 종료까지의 흐름을 기술한 것. 장점은 처리를 세분화하여 나타낼 수 있지만, 단점으로는 세분화를 공통화할 수는 없음.
- DFD(Data Flow Diagram): 인터페이스와 데이터베이스 사이의 처리를 기술할 수 있음. 플로차트와 달리 공통화 처리도 기술가능하다.

위 구조화된 설계의 단점은 **변경에 유연하게 대처하기 어렵다**이다. 하나의 항목이 바뀌면 수정되어야할 부분이 많아진다는 뜻이다. 

**객체지향 프로그래밍**는 위의 단점을 해결하기 위해 클래스, 상속, 다형성, 인스턴스 라는 개념이 도입되었다.
**객체지향 설계**는 시스템을 클래스의 집합으로 본다. 시스템 동작은 클래스간에 객체가 전달되며 실현되는 형태로 본다. 이때 클래스 간에 객체가 전달되는 것을 메시지 패싱(메시지 전달)이라고 한다.

책에서는 공수산정할 떄 쓰이는 여러 방법(맨먼스 개념, 기능 점수 방식)들을 설명하고 있는데 이는 읽고 넘어갔다.


## 총평

2장은 음.. 이 책의 방향이 어느쪽으로 갈지, 어떤 독자를 데리고 얘기하려는건지 대강 알 것 같기도 했다.


