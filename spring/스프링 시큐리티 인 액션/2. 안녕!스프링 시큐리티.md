간단한 예제 프로젝트를 만들어서 시큐리티와 mvc의존성만 추가했을 때 어떻게 동작하는지 확인함.

- 책에서는 curl을 사용하였지만, 나는 httpie를 사용

- 스프링 시큐리티 실행할 때 나타는 값 예)bc8e6c25-d7ea-4cf2-a199-e7e2b83ab739 이것은 user라는 키와 합쳐져서 base64로 인코딩된 뒤에 결과값이 Authorization헤더의 'Basic'과 함께  밸류값으로 들어간다. 예) Authorization: Basic [결과값]

## 스프링 시큐리티 인증 방식

1. 인증 필터가 요청을 가로챔
2. 인증 책임이 인증 관리자에게 위임
3. 인증 관리자는 인증 논리를 구현하는 인증 공급자를 이용
4. 인증 공급자는 사용자 세부 정보 서비스로 사용자를 찾고 암호 인코더로 암호 검증(이때 `UserDetailService`, `PasswordEncoder`사용)
5. 이 결과를 필터에 반환
6. 인증된 엔티티에 관한 세부 정보가 보안 컨택스트에 저장


- UserDetailService: 사용자에 대한 세부 정보를 관리하는 곳. 메모리에 자격 증명을 보관함.
- PasswordEncoder: 암호를 인코딩하거나 암호가 기존 인코딩과 일치하는지 확인함.
- AuthenticationProvider: 인증 논리를 정의하고 사용자와 암호의 관리를 위임.

- 보통 HTTP basic 인증은 사용하지 않음. 디코딩이 너무 쉬움.

-----

책에서는 이 클래스의 구현체로 `InMemoryUserDetailsManager`를 사용한다. 

이를 적용하면 콘솔에 자동 생성된 암호가 출력되지 않는다. 다만, 사용자가 없고 PasswordEncoder가 없기에 엔드포인트 호출이 되지 않는다.

따라서 적용하기 위해서는 자격 증명이 있는 사용자를 만들고, UserDetailsService에서 이를 관리하도록 추가하고, 주어진 암호를 UserDeatilsService가 저장하고 관리하는 암호를 이용해 검증하는 PasswordEncoder 형식의 빈을 정의한다.

책에서는 `NoOpPasswordEncoder`를 사용하는데,이는 암호를 평문으로 저장 하고 deprecated되어 대신에 최신식으로 변경하여 사용하였음.(PasswordEncoderFactories.createDelegatingPasswordEncoder())

기본구성만 이용하면 모든 엔드포인트에 대해 인증을 해야하는 등의 문제가 있는데 `WebSecurityConfigurerAdapter`클래스를 확장하여 이를 해결할 수 있다.

물론 현재 기준 위 클래스는 Deprecated되었으므로

```java
 @Bean
public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) {
    httpSecurity.authorizeHttpRequests((auth) -> auth
            .anyRequest().authenticated())
            .httpBasic(Customizer.withDefaults());
    return httpSecurity.build();
}
```

이 구문으로 대체하였다.

위 예제로 쓰인 인메모리 방식은 운영단계에서 분명 문제가 발생될 것이므로, 운영단계에서는 당연히 사용을 권장하지 않는다.

`AuthenticationProvider` 이것을 재정의햐면 `UserDetailsService`, `PasswordEncoder`를 사용할 필요는 없지만 보통 혼용하여 사용한다.



