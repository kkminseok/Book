이 챕터에서는 객체의 종류에 대해 다룬다.

VO, DTO, DAO, Entity 등에 대해 다룬다.
중요한 것은 이러한 개념이 무엇이고 이를 구현하는데에 애쓰지 말고 해당 개념들이 추구하는 방향과 이에 맞춰 설계를 어떻게 해야하는가에 대한 고민을 해야한다.

## 1. VO ##

VO는 ValueObject의 약자이다.
값 객체라는 뜻으로, 값 + 객체 이므로 정확히 따지자면 class타입이 아닌 거기서 생성된 오브젝트가 VO라고 생각할 수 있다.

값은 무엇인가?

값의 특성은 불변성, 동등성, 자가검증 3가지가 있다.

### 불변성

값은 변하지 않아야한다. 한번 생성된 인스턴스는 변하지 않아야한다.

이를 보장하기 위해서 `final`키워드를 사용하는데, 문제는 상속 및 객체 참조시에도 상속된 인스턴스나 참조 인스턴스에 대해서도 불변성을 유지해야 진정한 VO라는 것이다.

근데 이는 중요하지 않다. 불변성을 추구한다는 사실을 알고 있으면 된다.

불변성을 통해서 값에 대한 예측 가능성을 높이고 신뢰성을 보장하도록 한다. 이를 추구해야한다.

### 동등성

값은 항상 동일해야한다. 가령 '1=1' 은 어디서나 통용된다. '1=2'가 될 수 없다.

코드상에서 동등성을 가지지 않는 경우가 무엇이 있을까?

보통 `equals()`, `hashcode()` 메서드를 오버라이딩하지 않으면 인스턴스의 비교가 일치하지 않는 경우가 있다. 이는 오버라이딩 하지 않으면 서로 주솟값을 비교하기에 같지 않다고 판단하는 것이다. RGB클래스가 있다고 하자.

```java
RGB color1 = new RGB(255,255,255);
RGB color2 = new RGB(255,255,255);
```

두 컬러는 값이 같기에 같다. color1=color2이다. 하지만 위의 두 메서드를 오버라이딩 하지 않으면 결국 둘이 일치하지 않는다는 결과가 나올것이다.

따라서 동등성응 지니게 하기 위해서 두 메서드를 오버라이딩 하는 것이다.

이를 더욱 간편하게 해주는 애노테이션이 있는데, 바로 `@Value`이다. 더 나아가서 java16이상에서는 `recored` 키워드도 제공하니 이를 통해서 동등성을 보장하면 된다.

### 자가검증

스스로가 자기 값을 검증할 수 있어야한다.

```java
RGB color = new RGB(300,255,255);
```

이 값은 잘못된 것이다. 255를 초과한 값은 들어올 수 없어야한다. 이는 생성자에서 보통 예외처리를 두며 이처럼 본인 값에 대한 자가검증 처리가 되어야한다는 것이다.

## 2. DTO ##

DataTransferObject의 약자로 데이터를 읽고 쓰는것 외에는 어떤 비즈니스 로직이 들어가면 안되는 오브젝트다.

습관적으로 변수에 `private` 키워드를 적고 클래스상단에는 `@Getter`를 쓰는 습관을 버려야한다. 필요한 변수에만 `@Getter`를 사용하도록 하자.

`@Data` 애노테이션을 통해서 DTO특성을 살릴 수 있지만 데이터 중심적 사고를 하여 행동 중심의 객체지향적 사고를 방해하므로 추천하지 않는다고 한다.

## 3. DAO ##

DataAccessObject의 약자로

말그대로 DB연결관리, 데이터에 대한 CRUD연산 수행, 보안 취약성을 고려한 코드작성을 위해 생겨난 오브젝트다.

이 오브젝트의 목적은 도메인 조직과 Database연결을 분리함에 있기에 이에 맞춰서 설계하면 된다.

## 4. Entity ##

Entity는 3개의 단어로 나뉘어서 설명할 수 있다. 이를 구별해서 사용하는 사람도 있고 구별하지 않는 사람도 있다.

- 도메인 엔티티: 도메인 모델중에서 비즈니스로직을 가지고 식별자를 가진 모델을 도메인 엔티티라 부른다. 도메인에 대해서는 구글링을 통해 더 자세히 알아보면 좋을 듯 하다.
- DB 엔티티: 데이터베이스에서 유무형의 객체를 표현하기 위해 사용되는 용어이다.
- JPA 엔티티: 데이터베이스에 있는 데이터를 객체로 매핑하는데 사용되는 객체이다. `@Entity` 애노테이션을 통해서 표현할 수 있고 이를 통해 표현되는 객체를 영속성 객체라고 부른다.



## 결론 ##

위의 개념들을 다 알필요가 없다. 어떤 배경을 통해 개념들이 등장했고 어떤 방향으로 소프트웨어를 설계해야하는지에 대해 알면된다. 각각의 목적이 있고 결국 유지보수 및 개발을 생산성 있게 위해 등장한 개념일뿐이다. 각 개념들이 추구하는 방향으로 설계하자.


