SOLID라는 말은 많이 봤을 것이다. 유지보수성과 확장성을 높이는 개발원칙이다.
- S: 단일 책임 원칙(Single Responsiblity Principle)
- O: 개방 패쇄 원칙(Open Closed Principle)
- L: 리스코프 치환 원칙(Liskov Subsitution Principle)
- I: 인터페이스 분리 원칙(Interface Segregation Principle)
- D: 의존성 역전 원칙(Denpendency Inversion Principle)

자세한 설명은 검색해도 많이 나오기에 이 책에서 나온 내용을 보고 느낀점, 또는 인용하여 정리하겠다.

유지보수성은 무엇인가? 

1. 코드 변경으로 인한 영향 범위가 어느정도 되는가?
2. 의존성 관리가 제대로 되고 있는가?
3. 쉽게 확장이 가능한가?

SOLID원칙은 위 질문에 대한 해답을 준다. 영향범위는 축소하고 의존성관리는 쉬워지고 확장도 쉬워진다.

### 단일 책임 원칙

이 원칙의 키워드는 **책임**인데 책임을 정의하기 전에는 **액터**라는 개념을 정립해야한다.

- 액터: 메시지를 전달하려는 주체

즉, 어떤 클래스를 사용하게 될 액터가 1명(개)라면 단일 책임 원칙을 지키고 있는 것이고, 여럿이면 위반하고 있는 것이다.

따라서 액터가 1명이라면 클래스를 변경할 이유도 하나로 고정된다. 여러 액터가 사용하고 있다면 하나의 클래스를 수정할 해당 클래스를 사용하는 액터들도 수정될 위험이 있기 때문이다.


### 개방 폐쇄 원칙

이 원칙의 목표는 변경으로 인한 영향 범위를 최소화하고 확장하기 쉽게 만들라는것이다.
나의 생각으론 구현체를 만들 생각보다는 인터페이스, 등을 두어 기존 코드를 최대한 안 건들게 하는거 아닌가 싶다.

### 리스코프 치환 원칙

기본 클래스의 계약을 파생 클래스가 제대로 치환할 수 있는가?

```java
@Getter
@Setter
@AllArgsConstructor
public class Rectangle {

    protected long width;
    protected long height;

    public long calculateArea() {
        return width * height;
    }
}

class Square extends Rectangle {
    public Square(long length) {
        super(length,length);
    }
}

//Test

@Test
void 리스코프_치환테스트(){
    Rectangle rectangle = new Square(10);
    rectangle.setHeight(5);
    System.out.println(rectangle.calculateArea()); //결과 50 원하는결과 25
}
```

위 코드는 대표적인 리스코프 치환 원칙 위반 사례이다.

```java
//Square에 해당 내용 추가
    @Override
    public void setWidth(long width) {
        super.setWidth(width);
        super.setHeight(width);
    }
    
    @Override
    public void setHeight(long height) {
        super.setHeight(height);
        super.setWidth(height);
    }
```

이러면 해결이 되는가? 안된다. 의도에서 벗어났기 때문이다.

setHegiht나 setWidth나 둘 다 자기 속성(setHeight -> height) or (setWidth -> width)뿐 만아니라 다른 속성까지 건들고 있다.

이 부분에서 의도치않은 실수를 발생시킬 수 있다.

리스코프 치환원칙을 완벽히 지키기는 어렵다. 이를 지키기에는 초기 코드 작성자의 의도를 파악해야하는데, 직접 물어보는데에도 커뮤니케이션 비용이 있고 만약 퇴사자라면? 의도를 알기가 어렵다.

이렇기에 **테스트**코드를 작성하여 작성자의 의도를 포함시킬 수 있다. 
즉, 테스트 코드를 작성하여 초기 코드의 의도를 다른 사람들도 알 수 있게 하자.

### 인터페이스 분리 원칙

간단하게 인터페이스에 대한 중요성을 나타내는 것인데, 어떤 클래스가 자신에게 필요하지 않은 인터페이스의 메서드를 구현하거나 의존하지 말아야한다는 것이다.

또한 하나의 인터페이스로 모든걸 해결하려고할 때에도 위배된다.

인터페이스는 구현을 강요하는데, 특정 클래스에서 필요없는 메서드를 인터페이스에 함부로 추가했다가는 해당 클래스에서 구현을 강제하게되어 쓸모도없는 코드를 작성하게 된다. 

### 의존성 역전 원칙

고수준/저수준 모듈이 추상화에 의존해야 한다는 원칙이다. 이를 이해하기 위해서는 **의존성**에 대해서 알아야한다.



