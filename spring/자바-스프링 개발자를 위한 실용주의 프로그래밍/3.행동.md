이번장의 챕터 이름은 '행동'이다. 
객체는 자아를 가진것처럼 동작해야하고 이처럼 '행동'하는 것이 중요하다.

위의 말이 무슨 의미이며, 어떻게 해야 객체를 행동하게끔 만들 수 있는지 살펴본다.

가장 쉬운 원칙은 **TDA(묻지말고 시켜라)**라는 원칙을 적용하는 것이다. 이 원칙을 통해 객체를 수동적인 객체를 능동적으로 바꿀 수 있다.

### - 행동위주의 사고와 데이터 중심의 사고

```text
자동차 클래스를 만들어주실 수 있나요?
```

라는 질문을 받았을때 누군가는 '자동차에는 바퀴, 운전대, 엔진,...이 있지?' 라고 생각하며, 다음과 같은 클래스를 만들 것이다.

```java
public class Car {
    private List<Wheel> wheels;
    private Handle handle;
    private Engine engine;
    ...
}
```

누군가는 '자동차는 탑승할 수 있고, 달릴 수 있어야하고, 가속 감속이 가능해야하지?'라고 생각하면 다음과 같은 클래스를 만들 수 있다.

```java
public class Car {
    public void drive();
    public void acclerate(float speed);
    public void decelerate(float speed);
    ...
}
```

전자는 **데이터 중심의 사고**라고 말할 수 있고 후자는 **행동 중심의 사고**라고 말할 수 있다.

코드가 더 뭐가 좋다라고 단정할 수 없지만, 객체지향적 사고에서는 후자가 더 나은 코드라고 볼 수 있다. 전자의 경우는 구조체라고 봐도 좋으며 객체지향에서는 객체는 서로 협력해야하는데 그러한면에서 후자는 행동을 요구하며 협력할 수 있기 때문이다.

객체를 구분 짓는 요인은 데이터가 아닌 행동이다.즉, 데이터가 객체를 결정하지 않고 행동이 객체를 결정한다.

```java
public class ???{
    private float speed;
    private float direction;
}
```

이 클래스의 이름을 뭐라고 정의할 수 있을까? 이 클래스의 이름은 새, 사람, 자동차 등등 속도와 방향을 가진 모든것이 될 수 있다. 

```java
public class ??? {
    public void ride() {
        ...
    }

    public void run() {
        ...
    }

    public void stop() {
        ...
    }
}
```

반면 위의 클래스는 탈 수있고, 달릴 수 있는 탈 것(Vehicle)이라는 명칭을 달 수 있을 것 같다.

이처럼 데이터가 객체를 결정하는것이 아닌, 행동을 통해 객체를 결정할 수 있게 된다.

**덕 타이핑**이라는 말이 있다. 

```text
만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다.
```
라는 말인데, 이 말은 **행동이 같다면 같은 클래스**로 부르겠다는 말이다.

덕타이핑 예제는 많다. 간단하게 의사코드를 적어보겠다.

```text
오리{
    꽥꽥();
    걷기();
}

알수없는 어떤 새{
    int 나이;
    꽥꽥();
    걷기();
}
```

덕타이핑을 지원하는 언어는 `오리 = new 알수없는 어떤 새` 라는 구문이 통한다.
알수없는 어떤 새가 데이터를 더 가지고 있다해도 **행동이 같다면 같은 클래스**로 판단하는 덕타이핑 관점에서는 맞는말이다.


다시 자동차 얘기에서 후자의 코드에서 메서드에 대한 구현을 추가해야한다. 예를들어서

`public void acclerate(float speed)`이 메서드를 구현한다고 생각해보자.

```java
public class Car {
    //속성 생김.
    private int speed;
    public void acclerate(float speed){
        this.speed += speed;
    };
    ...
}
```

메서드를 구현하려고하다보니 클래스에 속성이 생겼다. 이는 별로 좋지 않은 상황이다. 결국 데이터 위주로 사고로 돌아갔고, 이는 구현에 집중해서 그렇다. 행동위주의 사고를 도와줄 수 있는 좋은 문법이 있다. 바로 **언터페이스**이다.

인터페이스는 속성을 가지지도 않고 일반적으로 메서드 구현을 못하도록 강제하기에 행동에 대해서만 생각할 수 있다.

```java
public interface Car {
    public void acclerate(float speed)
    ...
}
```

이렇듯 인터페이스는 구현을 하기 전 일종의 약속이 되는것이다. 인터페이스를 잘 설계해놓으면 협업할때 각자 구현에 집중하기만하면 된다. 이렇듯 인터페이스의 중요성때문에 '인터페이스는 곧 계약이다'라는 말까지 생겨난 것이다.

따라서 중간중간 인터페이스가 잘 지켜지고 있는지 확인도 필요한데, 이때 필요한게 **테스트**이다.

여기서 `인터페이스 = 행동` 이라고 이해할 수 있는데 인터페이스는 그저 어떤 객체가 자신의 행동을 알려주기 위한 방법, 수단을 나타낸 것에 불과하다.

인터페이스라는 용어자체는 Java에서도 쓰일 수 있지만 시스템 설계에서도 쓰일 수 도 있다. 어떤 행동에 대한 지시 방법을 타인에게 알려주는 하나의 메시지라고 이해하는게 편하다.

인터페이스를 사용하면 객체간의 결합도를 낮출 수 있고 코드의 재사용성과 모듈화도 가능해진다는 장점이 있다. 고로 인터페이스는 중요하다.



