6장에서 안티패턴을 학습하면서 서비스에 대한 언급을 하였다.

나도 이 책을 읽기전에 이런 고민을 해봤었다.

'서비스란 뭐지?'라고 생각했고, 점차 지나면서 '비즈니스 로직을 작성하는곳'이라고 까지만 인식했다. 책을 읽으면서 이 생각은 바뀌었다. 

서비스란 `@Service`애노테이션에 달려있는 주석을 통해 어떤 의민지 알 수 있다.

1. DDD에서 영감을 받아 만들어진 애노테이션이다.
2. J2EE패턴 중 하나인 비즈니스 서비스 파사드처럼 사용될 수 있다.

보통 '비즈니스 로직을 작성하는 곳'이 서비스라고 인식하는 경우가 많다.

앞에서 비즈니스 로직은 도메인 객체가 담당해야할 일이라고 했기에 위의 말을 틀렸다. 

서비스는 **도메인 객체가 처리하기 애매한 '연산' 자체를 표현하기 위한 컴포넌트'**이다.

무슨 말일까?

```text
가격 = 상품 가격 - (상품 가격 * 쿠폰 최대 할인율) - 사용자 마일리지
```

의 식이 있다고 치자.

서비스에서 해당 식을 가지고 사용자가 지불할 금액을 계산한다고 하면 다음과 같은 절차로 나타낼 수 있겠다.

```text
1. 사용자가 가진 쿠폰중 쿠폰 최대 할인율을 for문을 돌려 찾는다.
2. 사용 가능한 쿠폰인지, 할인율이 가격보다 높은지 검증한다.
3. 쿠폭을 적용하기 위해 가격에서 쿠폰 할인율을 뺀다.
4. 사용자의 마일리지를 찾아서 가격에서 뺀다.
```

앞에서 자가검증과 같은건 도메인이 담당해야한다. 그렇다면 사용가능한 쿠폰인지, 할인율을 가격과 비교하는것은 도메인에서 담당한다고 쳐도 연산식 자체는 어디에 둘 것인가 고민이 된다. 쿠폰 도메인? 상품 도메인? 유저 도메인? 어디에 둬야할까
셋 다 애매하다. 이런경우 가격 계산을 위한 클래스를 하나 둔다.

```java
class PriceManager {

    public int calculate(User user, Product product, List<Coupon> coupons) {
        ...
    }
}
```

그리고 위 클래스를 이용해서 계산 로직을 작성했던 서비스에 담아두면될 것 같다.

그런데 위 클래스를 굳이 `priceManager`라고 하지 않아도 될 것 같다. 저 클래스가 **서비스의 역할을 하고 있기 때문에 서비스라고 불러도된다**

```java
class PriceService {

    public int calculate(User user, Product product, List<Coupon> coupons) {
        ...
    }
}
```

서비스란 로직자체가 연산이라서 어떠한 객체도 갖고 힘들어서 만들어진 클래스를 **서비스**라고 한다. 

PriceService 서비스고, PriceService를 호출하는 곳도 Service라면 둘을 어떻게 구분해야하나? 둘은 같지는 않다. 그렇기에 구분을 해줘야한다. 

PriceService와 같이 도메인들이 처리하기 애매한 연산들을 담아서 처리하는 곳을 **도메인 서비스**라고하고, 연산들을 모아서 정제하고 알맞은 값들을 설정해주는 곳, PriceService, 도메인 등을 호출하는 서비스를 **애플리케이션 서비스**라고 한다.

그러면 이제 `2. J2EE패턴 중 하나인 비즈니스 서비스 파사드(정면)처럼 사용될 수 있다.` 이 말을 이해할 수 있다. 스프링의 서비스는 도메인과 도메인 서비스가 협력할 수 있는 일종의 협력의 장을 마련해준다. 스프링 서비스는 회의실이고, 도메인과 도메인 서비스는 회의에 참여한 인원이라고 보면 될 것 같다.

그런데 위에서 `PriceService`라고 했지만 이를 도메인 관점으로 `Cashier(점원)`라는 이름을 주면 어떨까? 점원이 가격을 계산하는건 전혀 어색하지 않다.
클래스의 역할을 이름을 짓는 순간부터 결정된다. 앞에서 `PriceServie`는 가격과 관련된 모든 로직들이 들어갈 것만 같다. 점차 시간이 지날수록 알고리즘 덩어리가 될 확률이 높다. 도메인과 도메인 서비스는 이름으로 나누는 것이 아니다. 행동으로 결정된다. 따라서 Service가 붙는다고 해서 서비스가 되는것도 아니다. `Cashier`이지만 도메인서비스의 역할을 하고있다. 아직까지는 `PriceService`와 하는 **역할은 같기때문이다.** 하지만 이름을 저렇게 지었기에 도메인 모델로 **발전**할 수 있는 사고를 지니게 할 수 있다. 

이제 이렇게 생각하면 초기 프로젝트를 설계할때 어떤식으로 설계하면 좋을까?

```text
도메인 모델 > 도메인 서비스 > 애플리케이션 서비스
```

순으로 설계하면 좋을 것이다. 왜냐하면 의존성도 애플리케이션 서비스 -> 도메인 서비스 -> 도메인순으로 있고 그렇기에 테스트 작성시 편하기 떄문이다. 

자고로 서비스는 **불변**해야하며, 그래야하기에 서비스에는 **생성자 주입**만을 사용해서 의존성 관리를 해야한다. 불변성을 가지고 있어야 순환참조가 일어나지 않을 가능성이 크다. 심지어 스프링 팀의 시니어 개발자는 **필드 주입을 없애고 싶다**라고 까지 말했다고 한다. 따라서 서비스는 무조건 생성자 주입을 사용해야 한다.






