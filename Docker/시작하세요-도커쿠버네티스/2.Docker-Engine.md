# 도커 엔진

도커이미지 구성

```docker
저장소/이미지:태그명
```

- 컨테이너 생성 명령어
- 컨테이너 목록 확인
- 컨테이너 삭제
- 컨테이너 포트 바인딩 방법
- 컨테이너 환경변수 설정 => 비추천 도커스웜모드의 secret이나 쿠버네티스 secret 추천
- link옵션 => 공식문서상 레거시 기술로 도커 브리지 사용 추천
- 데이터 볼륨 3가지 방식
    - 호스트와 볼륨 공유(호스트의 디렉터리를 컨테이너 디렉터리에 덮어씌움)
    - 볼륨컨테이너(호스트와 파일을 공유하는 컨테이너를 하나 둬서 컨테이너들끼리 공유시킴)
    - 도커 볼륨(도커 자체가 제공하는 볼륨)
- 도커 네트워크
    - bridge: 아무것도 설정안한 경우 docker0 브리지 사용
        - 사용자 정의 네트워크 사용
        - 서브넷, 게이트웨이, IP할당 등 임의로 설정가능
    - host
        - 호스트의 네트워크 사용
    - none
        - 아무 네트워크도 사용하지 않음.
    - 컨테이너 네트워크
        - 다른 컨테이너의 네트워크를 그대로 사용(eth0이 같음)
    - 브리지네트워크, net alias방식
        - **도커 내장DNS**를 통해 호스트를 등록
- 도커 로그
    - syslog
    - fluentd log(소프트웨어 프로젝트)

컨테이너 하나에 프로세스 하나만 실행하는 것이 도커의 철학

컨테이너 -d 옵션 사용시 컨테이너 내부에서 프로그램이 foreground로 실행되어야함.

컨테이너 메모리,cpu, cpu 스케줄링, Block I/O 등 자원제한이 가능하다

-----

- docker save vs docker export
    - export는 컨테이너 및 이미지 설정정보 저장하지 않음
- 도커 파일 추출은 추천하지않음
    - 레이어 구조가 아니라서 비효율적
- 이미지 배포방식
    - 도커허브
    - 사설 레지스트리

레지스트리 api라는것이 존재 보안, 인증 등의 설정도 가능


-----

### Dockerfile

개발한 애플리케이션 컨테이너화 방법
1. os 이미지 컨테이너 생성
2. 해당 컨테이너에 애플리케이션 환경 구축
3. 컨테이너를 이미지로 커밋

이러한 작업을 줄이기 위해 등장한 Dockerfile

- Dockerfile이 위치한 곳에는 이미지 빌드에 필요한 파일만 있는게 바람직
    - 컨텍스트는 하위 디렉터리도 전부 포함하여 빌드하게 되므로 불필요한 파일이 있으면 느려지고 호스트의 메모리도 지나치게 점유함.
    - `.dockerignore`라는 파일로 컨텍스트에서 제외시킬 수 있음.

- Dockerfile에서 명령어 한 줄이 실행될때마다 새로운 컨테이너가 하나씩 생성되며 이를 이미지로 커밋
    - 레이어 및 컨테이너가 명령어 줄 수만큼 생기고 컨테이너는 삭제됨.
    - 한 번 이미지 빌드를 마친 것은 캐시를 사용하여 빌드

- 멀티 스테이지 빌드: Dockerfile안에 여러 개의 FROM 이미지를 정의함으로써 생성될 이미지 크기를 줄임
    - `COPY --from=0 /root/mainApp` 예제에서 `--from=0`은 첫 번째 FROM에서 빌드된 이미지의 최종상태를 의미 (이름 명시도 가능 FROM ~ as [이름명])
    - `alpine`은 프로그램에 실행에 필수적인 런타임 요소가 포함된 리눅스 배포판 이미지. 기억하자.
- ADD vs COPY
    - COPY는 로컬 파일만 추가 가능 ADD는 외부 파일도 추가 가능
        - `ADD https://raw.github~ /home`가능
    - ADD의 `tar`파일의 경우는 자동으로 압축해제해서 전달
    - 하지만 보안, 유지보수상 **ADD**는 권장되지 않음.
- ENTRYPOINT vs CMD
    - entrypoint는 커맨드를 인자로 받아 사용
        - `docker run -i -t --entrypoint="echo" ~ ubuntu:14.04 /bin/bash`
        => 결과는 'echo /bin/bash'  `entrypoint`가 없으면 '/bin/bash'실행
        - 즉 `entrypoint`가 있으면 cmd는 인자의 기능을 함.
    - 배열형태로 입력하지 않으면 `/bin/bash -c`가 자동으로 붙음
    - 배열형태로 입력하면 입력된 명령어가 그대로 이미지에서 사용

레이어 구조로 되어있기에 `Dockerfile`에서 이미지 삭제한 명령어를 넣어도 실제 삭제되지 않아 이미지 크기가 커질 수 있음.
이를 방지하기 위해 `&&`로 각 `RUN`의 명령어를 하나로 묶으면 됨.

|as-is|to-be|
|--|--|
|RUN fallocate -l 100m /test/dummy| fallocate -l 100m /test/dummy && rm /test/dummy
|RUN rm /test/dummy|
