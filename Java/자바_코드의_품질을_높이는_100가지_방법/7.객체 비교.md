## [055] equals 메서드 대신 참조 동등성 비교

종종 `equals()` 대신 `==`를 사용하는 경우가 있음. 

자바에서는 값이 작으면 캐싱 되어 나타난다.

자바 스펙에서는 -128 ~ 127라고 한다. 

```java
Integer i1 = 100;
Integer i2 = 100;
if(i1 == i2) ~ // true

Integer i1 = 1000;
Integer i2 = 1000;
if(i1 == i2) ~ // false

// 자바 가상머신 동작에 따라 다르지만 밑의 경우도 있다.
String greeting = "Hello";
if(greeting == "Hello") // true
// 밑은 런타임에 생성되는 문자열이므로 다르다고 판단할 수 있다.
String greeting2 = greeting + "!";
if(greeting2 == "Hello!") // false
```

JVM 옵션을 조절해서 캐싱 데이터 범위를 늘릴 수는 있다.

- 원시 래퍼 타입은 참조 동등성으로 비교하지 않는다. 문자열도 마찬가지다.
- 원시 래퍼 타입 사용하지 말자.


## [056] equals()가 내용을 비교한다고 간주함.

eqauls()가 오버라이딩 되지 않은 경우 묵시적으로 `==`를 사용하게 되는데 대표적으로 자바의 배열이 있다. 이런 경우 `Arrays.equals()`나 `Arrays.deepEquals()`라는 정적 메서드를 사용해야 한다.

혼동하기 쉬운 클래스 목록|
-----|
StringBuilder, StringBuffer|
AtomicInteger, AtomicReference|
WeakReference, ..|
java.security.key|
Stream|
ArrayDequeue, 등 컬렉션|
Collections.unmodifiableCollection(), ...|

- `equals()` 오버라이딩 여부를 보자. 
- 컬렉션 비교는 잘 확인하자

## [057] URL.eqauls() 사용

이건 일반적인 `equlas()`와 동작방식이 다르다고 한다.

저 메서드는 문자열 비교라기 보단, 두 URL이 네트워크적으로 동일한 리소스를 가리키는지 확인한다.

이러다보니 네트워크 통신을 하게 되는데 그 과정에서 성능 저하나 네트워크 상태에 따른 오류를 발생시킬 수 있어서 이를 인지하고 사용하자는 내용

- `java.net.URL`보다는 `java.net.URI`를 사용한다.

## [058] 스케일이 다른 BigDecimal 비교

`BigDecimal`도 `equals()`가 구현되어있다. 

언스케일값(지수)과 스케일값이 있는데, 0.1234라는 값이 있으면 언스케일 값은 1.234, 언스케일값은 4로 표현될 수 있다. 이는 또 12.340 , 언스케일값은 5로 표현될 수 있다. 
이런 부분에서 발생하는 문제가 있다. equals()는 두 값의 언스케일, 스케일 값을 비교하다보니 다음과 같은 문장이 틀리게 된다.

```java
@Test
@DisplayName("BigInteger 비교 특이점 테스트")
void testBigIntegerComparison() {
    BigDecimal x = new BigDecimal("0");
    BigDecimal y = new BigDecimal("0.0");

    Assertions.assertNotEquals(x, y);
}

//eqauls()에 대한 정보는 코드를 까보면 바로 나온다.

public boolean equals(Object x) {
        if (!(x instanceof BigDecimal xDec))
            return false;
        if (x == this)
            return true;
        if (scale != xDec.scale)
            return false;
        long s = this.intCompact;
        long xs = xDec.intCompact;
        if (s != INFLATED) {
            if (xs == INFLATED)
                xs = compactValFor(xDec.intVal);
            return xs == s;
        } else if (xs != INFLATED)
            return xs == compactValFor(this.intVal);

        return this.inflated().equals(xDec.inflated());
    }
```


- BigDecimal 비교는 `compare()`를 사용하는게 좋다.
- `equals()`를 사용해야 한다면 `stripTrailingZeros()`함수로 불필요한 0을 제거한다.

## [059] 관련 없는 타입에 equals() 사용

Integer와 String처럼 서로 전혀 다른 타입을  `==`연산자로 비교하는 경우 에러를 일으킴.
`equals()`도 모든 타입의 객체를 파라미터로 받아서 소용이 없음. 여러 비즈니스로직이 섞이면 이를 알아채기 어렵다.

- 코드 커버리지에 주목하면 해결할 수도 있다 항상 false로 평가되는 조건이 있다면 무언가 잘못되었음을 알아챌 수도 있다.

## [060] 잘못된 eqauls() 구현

```java
class MtEntity {
    ...
    public boolean equals(Object o) {
        ...
        MyEntity other = (MyEntity) o
        return name.eqauls(other.name) &&
                attributes.eqauls(attributes) &&// <-- 실수
                data.eqauls(other.data)
    }
}
```

이런 경우를 말한다. 자기자신을 비교하는 경우가 존재하는 경우이다.

- 가급적 직접 구현하지 않고, IDE를 이용해서 생성한다. 필드를 추가할 때도 마찬가지이다. 차라리 기존 코드를 지우고 다시 생성하는게 나을 수 있다.
- 자바16부터 나온 `record` 클래스를 사용한다. 이는 컴파일러가 자동으로 `equals()`메서드를 생성한다.
- 정적분석 툴을 사용하는 것도 괜찮다.

## [061] 배열 필드 hashCode()

`hashCode()` 메서드 구현시에 발생하는 문제를 말함. 자바7 이전에는 수동으로 구현해서 문제가 많았지만 `Object.hash()`함수의 등장으로 개선됨. 필드가 배열을 가지고 있으면 잘 써야하는데

만약 2개의 필드가 int, string형 배열을 가지고 있으면 `Objects.hash(Arrays.hashCode(intData), Arrays.hashCode(stringData))`이런식으로 구형해야함. 레코드 자료형도 배열들을 참조 방식으로 비교하기에 내용을 비교하려면 직접 구현해야한다.

- hashCode()를 수동으로 구현하지 않는다. IDE를 사용해서 구현한다.
- 배열에 대해서는 신중히 생각해서 구현한다.

## [062] eqauls()와 hashCode() 불일치

eqauls()에 맞게 hashCode()도 구현되어야 하는데 요구사항 추가 등으로 일치하지 않는 경우가 생길 때를 말함.
필드의 순서가 다른 경우를 비교할 때도 문제가 생길 수 있는데, `toUpperCase(), toLowerCase()`등의 함수를 모두 실행하여 사용하면 된다. 

이부분은 내용이 좀 글로 다루기 어렵다.

## [063] 특정 반환값에 의존하는 compare()

자바 객체의 순서를 정의하는 표준 방식이 2가지 있다. `Comparator.compare()`나 `Comparable.compareTo()`를 사용하는 것이다.

```java
public record User(String name, int age)implements Comparable<User> {
    @Override
    public int compareTo(User o) {
        int res = name.compareTo(o.name);
        return res != 0 ? res : Integer.compare(age, o.age);
    }
}

//
@Test
@DisplayName("63 compare() 문제")
void compareMistakeTest() {
    User u1 = new User("Mary", 30);
    User u2 = new User("Mary", 20);
    User u3 = new User("Joe", 30);
    Assertions.assertEquals(1, u1.compareTo(u2));
    Assertions.assertEquals(3, u1.compareTo(u3));
}
```

`String.compareTo()`는 -1,0,1이 아닌 다양한 값을 반환하는데 그 값을 반환하고 있기에 '3'이라는 값이 나올 수 있다.

- 직접적이든 간접적이든, `compare()`, `compareTo()`의 호출 결과는 1,-1처럼 0인 아닌 상수와 비교하지 않는다.
- 비교자용 알고리즘을 굳이 만들지 않는다.

## [064] 동일한 객체를 비교할 때 0을 반환하지 않음.

비교할 때 `compare()` 인터페이스를 구현할 때 계약 규칙이라고 하는 것이 있다. 어떤 값이 더 크면 1을 반환하고 작으면 -1 같으면 0을 반환하는 계약인데 이를 무시하는 경우이다. 이를 무시하면 테스트 코드에서 일관성이 깨지게 될 가능성이 있으며 다른 개발자가 이를 봤을때 이해 못하는 경우가 있을 것이다.

- 비교 메서드를 구현할 때는 비교 대상이 서로 동일한 경우를 항상 고려한다. 
- 객체를 자기 자신 또는 동일한 객체와 비교하는 유닛 테스트를 추가한다.

## [065] 뺄셈을 이용한 숫자 비교

숫자를 비교할 때 뺄셈을 쓰면 편리할 때가 있다.

```java
public class IntObj implements Comparable<IntObj>{
    int i;
    
    IntObj(int i) {this.i = i;}
    @Override
    public int compareTo(IntObj o) {
        return i = o.i;
    }
}
```

이런 코드인데 값이 너무 커지면 오버 플로우가 날 것이다.

```java
@Test
@DisplayName("65 숫자뺄셈 compare()문제")
void compareMinusMistakeTest() {
    IntObj x = new IntObj(2_000_000_000);
    IntObj y = new IntObj(0);
    IntObj z = new IntObj(-2_000_000_000);

    Assertions.assertTrue(x.compareTo(y) > 0);
    Assertions.assertTrue(y.compareTo(z) > 0);
    Assertions.assertFalse(x.compareTo(z) > 0); //-294967296
}
```

마지막의 경우 False가 나오는 것에 주목해야한다. 오버 플로우가 나서 이상한 값으로 대체된 것을 볼 수 있다.

`compareTo()` 함수를 잘못 오버라이딩 하면 여러군데서 문제가 생길 수 있음을 책에서는 말한다. 예를 들어서 Set에서 특정 원소를 제거하고 다른 원소를 찾을때 사용자가 오버라이딩한 `compareTo()`를 호출하여 의도치않게 동작하게 된다거나 하는 등의 문제가 있다.

- `Integer.compare(i, o.i);` 이런식으로 비교한다.
- `i == o.i ? 0 : i < o.i ? -1 : 1;`이런식으로도 비교할 수 있다.
- 유닛 테스트를 필수적으로 작성한다.
  

## [066] 비교 메서드가 반환하는 NaN 값 무시

비교 메서드를 직접 만들면 부동소수점 숫자를 제대로 처리하지 못할 위험이 있다.

위와 마찬가지로 직접 구현하지 않고 `Dobule.compare()` 함수를 사용해서 비교하는 것을 추천한다.

## [067] 비교 메서드에서 객체를 키 시퀸스로 표현하지 못함.

여러 필드를 비교하는 일반적인 방법은 각각을 차례로 비교하다가 차이를 확인하면 중단하는 것이다.
이렇게 작성할 경우 나타날 수 있는 실수들이 있다. 필드를 누락해서 비교하거나 null에 대한 처리가 부족하여 null과 비교시 true가 되거나 

- 비교 메서드를 구현할 때는 객체를 키 시퀸스로 표현하고 하나씩 비교한다.
- 구아바의 ComparisonChain을 사용한다. 
- 무작위 프러퍼티 테스트를 만들고 검증한다.

## [068] 비교자의 난수 반환

자바 스트림 API는 스트림 내용을 뒤섞는 메서드를 제공하지 않음. sorted() 메서드로 정렬할 수는 있다.
이를 토대로 직접 구현하는 경우가 있는데 거기서 발생하는 문제를 말한다.

- 정렬을 이용해 객체를 무작위로 섞으면 **IllegalArgumentException**이 발생할 수 있다. 정렬과 셔플은 다른 알고리즘이고 `Collections.shuffle()` 등의 전용 메서드를 사용하는 방법이 있다.


