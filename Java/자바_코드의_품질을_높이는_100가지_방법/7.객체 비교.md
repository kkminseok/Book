## [055] equals 메서드 대신 참조 동등성 비교

종종 `equals()` 대신 `==`를 사용하는 경우가 있음. 

자바에서는 값이 작으면 캐싱 되어 나타난다.

자바 스펙에서는 -128 ~ 127라고 한다. 

```java
Integer i1 = 100;
Integer i2 = 100;
if(i1 == i2) ~ // true

Integer i1 = 1000;
Integer i2 = 1000;
if(i1 == i2) ~ // false

// 자바 가상머신 동작에 따라 다르지만 밑의 경우도 있다.
String greeting = "Hello";
if(greeting == "Hello") // true
// 밑은 런타임에 생성되는 문자열이므로 다르다고 판단할 수 있다.
String greeting2 = greeting + "!";
if(greeting2 == "Hello!") // false
```

JVM 옵션을 조절해서 캐싱 데이터 범위를 늘릴 수는 있다.

- 원시 래퍼 타입은 참조 동등성으로 비교하지 않는다. 문자열도 마찬가지다.
- 원시 래퍼 타입 사용하지 말자.


## [056] equals()가 내용을 비교한다고 간주함.

eqauls()가 오버라이딩 되지 않은 경우 묵시적으로 `==`를 사용하게 되는데 대표적으로 자바의 배열이 있다. 이런 경우 `Arrays.equals()`나 `Arrays.deepEquals()`라는 정적 메서드를 사용해야 한다.

혼동하기 쉬운 클래스 목록|
-----|
StringBuilder, StringBuffer|
AtomicInteger, AtomicReference|
WeakReference, ..|
java.security.key|
Stream|
ArrayDequeue, 등 컬렉션|
Collections.unmodifiableCollection(), ...|

- `equals()` 오버라이딩 여부를 보자. 
- 컬렉션 비교는 잘 확인하자

## [057] URL.eqauls() 사용

이건 일반적인 `equlas()`와 동작방식이 다르다고 한다.

저 메서드는 문자열 비교라기 보단, 두 URL이 네트워크적으로 동일한 리소스를 가리키는지 확인한다.

이러다보니 네트워크 통신을 하게 되는데 그 과정에서 성능 저하나 네트워크 상태에 따른 오류를 발생시킬 수 있어서 이를 인지하고 사용하자는 내용

- `java.net.URL`보다는 `java.net.URI`를 사용한다.

## [058] 스케일이 다른 BigDecimal 비교






