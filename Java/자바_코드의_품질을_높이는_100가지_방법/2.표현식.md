잘못된 연산자사용, 잘못된 우선순위 판단 등, 자바 표현식에서 발생하는 버그에 대해 다루는 장.

## [001] 숫자 연산자 우선순위 오해

- 일반적인 연산자(사칙연산, 등)은 실수할 일이 적은데, **이진 시프트**처럼 이색적인 연산자가 등장하면 문제가 생기기 시작한다.
    - 덧셈과 우선순위를 헷갈리는 일이 많다. `xmin + ymin >> 8`같은 코드. 덧셈이 우선순위를 더 높게 가진다.
    - **명시적으로 괄호를 추가하여 우선순위를 나타내자, 굳이 곱셋 또는 나눗셈에 비트 시프트 연산자 사용하지 말자. 그냥 쓰나 성능도 비슷하다.**
    - `hashcode()`를 직접 작성하지 않고 IDE에게 맡기면 실수를 덜 할 확률도 올라간다.
- 비트연산자(`&`, `|`)와 사칙연산의 우선순위도 조심해야한다. 덧셈의 경우 비트 연산자보다 우선순위가 더 높다.
    - 비트 연산을 할때 굳이 산술 연산자를 같이 사용하지말고, 비트 연산자만 사용하는것도 실수를 방지하는데 도움된다.
    - **`&`가 `|`보다 우선순위가 높으므로 괄호를 써서 명확하게 우선순위를 나타내자**

## [002] 조건식의 괄호 누락

- `&&`, `||`의 우선순위를 헷갈리지 말자. 위와 마찬가지로 헷갈리면 괄호로 묶자.
- 삼항 연산자 우선순위도 마찬가지
- 조건연산자 + `null` 우선순위도 마찬가지

내 생각에는 대부분의 경우 괄호를 추가하면 실수를 방지할 수 있다.


## [003] 덧셈이 아닌 결합으로 작동

`String entryName = "Entry#" + index + 1;`

- index가 '4'일 때 entryName의 값은? => Entry#41이다. 이는 의도치 않은 결과이다.
- `index+1`을 괄호로 묶거나 섞어 쓰지않고 나눠써서 해결한다.

## [004] 멀티라인 문자열 리터럴

긴 문자열을 다룰 때, " " 와 `+`연산자로 줄을 나눠가며 다뤘는데, 그러다보니 예상치 못한 실수를 범할 수 있었다.

```java
String text ="<html>my" +
" hello " +
"</html>".replace("hello", "bye");
```

이런 구문이 있으면 마지막줄에만 `replace()`가 적용되어서 아무런 변화가 일어나지 않는 다는 것.

문자열을 괄호로 감싸거나, 변수에 먼저 저장한 뒤 함수를 호출하거나, 자바 15에서 제공하는 텍스트 블록(`""" """`)를 사용하도록 한다.

## [005] 단항 덧셈 연산자

이 부분은 그냥 넘어가도 될 듯 하다. 실수 잘 안 할 것 같다.

```java
return "User not found" +
+ '"' + userName + '"';
```

이런식으로 쓸 경우 문제가 있다는데, 누가 이렇게 쓸까?

## [006] 조건 표현식의 묵시적 타입 변환

```java
private Double valueOrZero(boolean condition, Double value) {
    return condition ? value : 0.0;
}
```

이 함수는 조건식을 실행하고 다시 박싱(boxing)을 한다. 원시 타입을 박싱할 때 `valueOf()`등의 정적 메서드를 묵시적으로 호출한다.

```java
private Double valueOrZero(boolean condition, Double value) {
    return Double.valueOf(condition ? value : 0.0);
}
```

이렇게 코드가 묵시적으로 변환될 것이고, 이는 2가지 문제가 존재한다. 

1. `value`는 항상 박싱된다, 이미 두 개의 박싱된 값이 있어서 메모리를 낭비할 위험이 존재한다.
3. `valueOrZero(true, null)`을 호출하면 NullPointerException이 발생한다.

원시값을 사용하는것이 실수를 줄일 수 있다고 한다. 저 함수가 for문 안에서 수 만번 실행되면 성능의 문제가 있을 수 있다.

## [007] 비단락 논리 연산자 사용

- 단락연산자: `&&`,`||`와 같은 것
- 비단락연산자: `&`,`|`와 같은 것

비단락 연산자를 잘못 사용하면 우선순위 문제, 동작방식 등에서 문제가 발생하므로 결론은 잘 모르면 사용하지 말라인데, 나는 잘 사용하지 않으므로 넘어가겠다.

## [008] &&와 || 혼동

복잡한 식이 있으면 진짜로 혼동하는 경우가 있는데 이러한 경우에는 **드 모르간 법칙**을 사용해서 식을 해결해나가면 좋다.

예를 들어서 `!(a||b)`인게 있다면 `!a&&!b`로 써야하는데 이 과정에서 실수가 있거나 하는 등의 문제이다.

## [009] 잘못된 가변 인수 호출

- 가변인수를 사용할 때 인자에 `null`이 들어가지 않도록 조심하자.
- 가변인수에 컬렉션을 넣을때 조심하자.
- 가변인수에 원시배열 넣을때도 조심하자.

그냥 가변인수에 배열, 컬렉션 넣지말라는 뜻인 것 같음.

## [010] 조건 연산자와 가변 인수 호출

- 조건 표현식에서 가변 인수를 사용할 거면 가급적 `if`문을 써라.

```java
@Test
@DisplayName("조건 연산자 가변 인수 호출")
void testConditionalOperatorVarargs() {
    printFormatted("Hello %s%n", "admin");
}
private void printFormatted(String format, Object... args) {
//        if(args.length == 0) {
//            System.out.printf(format, "user");
//        } else {
//        }

    // 위의 효과를 한 줄로 나타내고자 밑과 같이 쓰면 문제가 생김
    System.out.printf(format, args.length == 0 ? "user" : args);
}
//호출 결과

Hello [Ljava.lang.Object;@514646ef
```

이유는 자바 내부의 래핑 방식 떄문이다. 컴파일러는 전체 조건 표현식을 하나로 인지하기 때문에 `args.length == 0 ? "user" : args`의 공통 슈퍼타입인 Object가 인자로 넘어가기 때문이다.

## [011] 반환값 무시

어떤 메서드들은 값을 반환하는데, 이를 무시하는 경우를 일컫는다. `subString()`같은 메서드..
또는 어떤 메서드들은 실패하면 에러가 아닌 `false`를 반환하는데 이런 것도 잘 살펴봐야한다.

- 정적분석기로 통해서 함수의 결과가 무시됐을 때, 이를 감지할 수 있다.
- 반환값이 있는 API를 사용을 지양하면 된다.

책에서는 함수를 만들거나 할 때, 새로운 객체를 반환하는걸 추천한다. 이젠 GC의 성능이 크게 개선되었고, 이정도의 오버헤드는 무시할 수 있을 정도기 때문이다.


## [012] 새롭게 생성된 객체를 사용하지 않음.

```java
//이러고 끝
new Object();

//또한 이런거 예외를 생성하고 던지지 않음.
if(value <0) {
    new ILLegalArgumentException("~");
}
```

- 새로 만든 객체는 반드시 사용하도록 강제하는 것이 좋다. 정적 분석기에 이런 룰을 추가거나 이런 규칙을 어긋나면 명시적으로 주석을 달게끔 하거나 하는 등의 조치를 취한다.

## [013] 잘못된 메서드를 참조하는 바인딩

오버로드 또는 가변 인수가 있는 메서드 참조를 잘못사용하면 의도하지 않은대로 동작할 수 있다. 때문에 신중하게 사용해야 하며, 자신이 없으면 **람다**를 사용하도록 하자. 

## [014] 메서드 참조 시 잘못된 메서드 지정

```java
void givenWrongMethodReference() {
    List<Integer> list = Arrays.asList(0, -3, 3, -1, 1, 2);
    list.sort(Integer::max);
    // [0, -3 , 3, -1, 1, 2]
    System.out.println(list);
}
```

의도는 오름차순 정렬이였지만, 이는 정렬되지 않는다. `sort()`는 내부적으로 `compare()`를 호출하는데 이 메서드는 두 Integer 값을 받고 어느 쪽이 큰지 가리키는 int를 반환한다. `max()`함수는 두 Integer 값을 받고 int를 반환하기에 컴파일시에 문제가 발생하지 않고, 어느쪽이 더 큰지에 대한 값이 아닌, 더 큰 값 그 자체이기 때문에 정렬이 제대로 되지 않는다.

- 이는 유닛테스트를 작성하여 어느정도 해결할 수 있다.

## 후기

비트 연산자 같은건 실제로 다룰 일이 크지 않으므로 대강 보고 넘겼다. 사실 비트 연산자 뿐 만 아니라 몇 개의 방법론(?)은 뭔가 공감 되지 않았다.

뭔가 전체적으로 정리하면 다음과 같을 수 있겠다.

- 우선순위 잘 신경써라
- 우선순위 애매하면 괄호로 해결하라
- Java15 써서 텍스트 블록 쓰자..(이건 개인 의견)
- 가변 인수, 메서드 참조 그냥 잘 모르면 풀어서 써라




