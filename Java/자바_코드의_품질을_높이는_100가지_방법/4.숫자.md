## [026] 우발적인 8진수 리터럴 사용

8진수는 '0'으로 시작하는데, `int x =0123' 이렇게 실수로 쓰는 경우를 말함.

> 흠..

- 최선의 방법은 8진수 리터럴을 프로젝트에서 사용하는 것을 금지.

## [027] 수치 오버플로

수치 연산을 할 때 발생하는 오버 플로우, 언더 플로우에 대한 얘기

- 라이브러리 메서드를 통한 해결(보통 이런것들 잘 처리 되어있음)
- `BigInteger`같은 클래스 활용
- 가장 좋은건 먼저 고려해보기

## [028] 정수 나눗셈 중 반올림

```java
private double process(int value) {
    double half = value / 2;
    return half;
}
```

이런 경우 `process(2)`와 `process(3)`은 동일한 값을 지닌다. 

`double half = value /2.0` 이런식으로 수정되어야함.

- 명시적으로 사용한다.

## [029] Integer.MIN_VALUE의 절댓값

`Integer.MIN_VALUE`는 -2147493648인데 양수쪽에 대응하는 값이 없는 특수한 값이다.

이로 인해서 문제가 생길 수 있다.

```java
Assertions.assertEquals(Math.abs(Integer.MIN_VALUE), Integer.MIN_VALUE);
```

이런 코드가 해시코드에 난수와 함께 쓰이고 낮은 확률로 오류를 발생시킬 수 있으므로 주의하라는 내용

양수에 대응하는 값이 없어서 위의 식은 `True`가 된다.

- `Math.absExact()`를 사용하자. 위의 경우 음수를 반환하는 대신 예외를 던진다.(Java 15이상)

## [030] 홀수 검사와 음수

홈수검사하는데 음수가 들어올 경우 문제가 생긴다는 것. 

보통 양수만 고려하고 `value % 2 ==1`이런 코드를 넣는데 요구사항에 따라 음수가 추가되는 경우 문제가 생길 수도 있다는 것.

- `value % 2 != 0` 이런 코드를 쓰자.

## [031] 확장으로 인한 정밀도 손실

int -> float, long -> float, long -> double과 같은 변환이 일어날 때, 값의 정밀도가 손실되는 경우를 말함.

- float를 사용하지 않는 방향을 고려하거나
- 성능을 크게 신경 쓰지 않아도 된다면 `BigDecimal`을 사용한다.

## [032] 무조건적인 축소 변환


`long` -> `int`의 형변환

만약 int로 변환할 수 없는 큰 값의 경우 형변환시 문제가 생길 수 있다는 것.

- 캐스팅 연산시 먼저 고려해보자.
- `Math.toIntExact()`를 사용하면 범위에 벗어난 값이 들어온 경우 예외를 던지니 사용하는 것을 고려
- 정말 바꿔야하는가? 에 대한 고려도 생각해보자. 초 단위 같은건 long쓰는게 나을 수 있다.

## [033] 16진수 음수

비트연산에 대한 이야기인데 이해하기 어려워서 넘긴다

## [034] 복합 할당의 묵시적 타입 변환

```java
chat c = 'a';
c *= 1.2; // <- 't'가 된다.
```

`x *= y`는 풀어 쓰면 `x = (x의 타입)(x * y)`와 동일하기에 나타나는 문제점이 존재한다.

```java
byte b = getByte();
if (b < 0) {
    b += 256;
}
```

위의 문제 때문에 이 코드의 b의 값은 변경되지 않는다. 

- byte와 short타입은 가급적 지양하고 int나 long타입을 사용한다.
- 사용해야하는 경우 음수 입력을 검증하는 테스트를 만들거나 음수 입력 불가 조건을 검증하는 어설션을 추가한다,

## [035] 나눗셈과 복합 할당

`a *= b / c`에서 연산 순서는 `a = a * (b / c)` 이런식으로 진행된다. 의도치 않았다면 문제가 발생할 수 있다.


- 복합할당을 잘 모르면 쓰는걸 지양하자.

## [036] short 타입

제일 쓸모없는 원시타입. 이라고 책에서 그런다.

요즘 short의 최대값은 32,767은 그냥 넘는다고 생각하면 된다.

- private 메서드에서 직접 관리하면 사용할 일이 있을 수는 있겠다.

## [037] 비트 조작 알고리즘

비트 연산을 남발하면서 쓰면 시프트 연산 값 범위를 벗어나거나 하는 등의 문제가 있으니 주의하라.

- 경계값 테스트를 진행한다.
- 비트 연산 알고리즘을 직접 구현하지 않는다.

## [038] 음수 바이트

비트 연산이랑 `byte`타입이랑 섞여서 발생하는 문제를 얘기하는데.. 그럴 일이 많지 않으므로 넘어가겠다.


## [039] 잘못된 클램핑 순서

`max`와 `min` 함수의 순서를 헷갈리는 경우

> ;;;;

## [040] 특수한 부동소수점 수

### 부호가 있는 0: +0.0과 -0.0

부동 소수점에 +0.0과 -0.0이 존재하는데, 이 값을 서로 다른 값으로 박싱될 수 있다. 

- 이는 주의할만하다. `if (d ==-0.0) d = 0.0;`같은 코드를 넣어서 전처리하는 방법이 있다.

### 숫자가 아님: NaN

**NaN**은 숫자가 아님을 의미. 간혹 이 값이 튀어나올 수 있으니 주의하라는 말

- `Double.isNaN()`, `Float.isNaN()` 같은 메서드로 체크를 해본다.

### Double.MIN_VALUE는 최솟값이 아니다.

`Dobule.MIN_VALUE`는 4.9 * 10^-324인데, 이 값은 **0이랑 가장 가까운 양수이다.**즉, `double`자로형이 표현할 수 있는 **가장 작은 양수 값**이다.

`-Double.MAX_VALUE`를 사용해야 가장 큰 음수이다. 이 값은 약, -1.7976931... * 10^308인데, 이것은 0에서 아주 멀리 떨어진 거대한 음수이다.

따라서 후자의 값이 제일 작은 값이라고 할 수 있다. 근데 보통 전자와 같이 쓰는 경우는 `Integer.MIN_VALUE`값을 바꾸는데에서 실수하면 발생할 수 있다.

## 총평

책 잘못 읽었나 생각이 들었다.

사실 비트 연산같은 저수준은 다룰 일도 많지 않고, 잘 모르기에 사용해봐야겠다고는 크게 생각해보지 않았다. 뭔가 리스크도 크고 직관적이지 않고 다른이들에게도 이해를 요구하는 코드 같아보여서?..

아무튼 그렇긴한데, 중간중간 쓸모있는 지식들은 있었다. Double.MIN_VALUE얘기나 +0.0같은 얘기.. 필요성을 느낄때가 있는지는 모르겠지만 뭐..











