## [041] NullPointerException

### null 회피와 방어적 검사

- null을 최대한 사용하지 않으려면 메서드가 null을 반환하지 않고 파라미터로 null을 반환하지 않아야함.
    - `Objects.requireNonNull()`을 사용하여 방지를 하자.
    - 열거형을 사용해서 상태에서 Null을 추가하고 싶은 유혹을 참아라.

### null 대신 Optional 사용하기

`Optional`의 주요 목표는 값이 비어있음을 알림.

- `Optional.ofNullable(value`)를 남발하지 말자. 의도적으로 null이 절대 포함되지 않음을 나타내기 위해 `Optional.of(value)`도 적절히 사용할 줄 알아야 한다.

## [042] IndexOutOfBoundsException

배열 검사하다가 '<', '>' 이런거 잘못 쓰고, 빈 문자열이나 0 등 경계검사를 제대로 안하는 경우를 말함.

- 클라이언트로부터 인덱스 값을 받으면 즉시 경계범위를 검사한다.
- 연산자를 헷갈려하지 말자.

## [043] ClassCastException

이 예외가 발생하는 경우는 크게 두 가지라고 한다.

1. 명시적인 타입 캐스팅
2. 제너릭 타입이 인스턴스화될 때

### 명시적 캐스트

명시적 캐스트에서 예외를 방지하려면

```java
if (obj instanceof MyType) {
    ...
}
//java16

if(obj instance of MyType mytype) {
    ..//바로 사용 가능
}
```

처럼 한 번 `instanceof`로 감싸는게 좋다.

또 하나의 방법은 `getClass()`를 호출하는 것이다. 

### 제너릭 유형과 묵시적 캐스트

```java
List<String> list = new ArrayList<>();
List<?> objects = list;
((List<Object>) objects).add(1); //<-- 문제
printFirstItem(list);

//

printFistItem(List<String> list) {
    String s = list.get(0);
    System.out.println(s);
}
```

이는 `List<? extends CharSequence> list`처럼 **PECS**패턴으로 컴파일 에러를 막을 수 있다. 이를 더 우아하게 작성하면 `List<Collections.unmodifiableList(getList())>` 이런식으로 작성할 수 있다.

### 복수의 클래스 로더

모듈형 아키텍처에서 벌어지는 일인데, 복수의 클래스로더에서 같은 클래스 파일명이 있는 경우 문제가 생길 수 있다.

```java

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, World!");

        URL url = Main.class.getResource(".");
        ClassLoader parent = System.class.getClassLoader();
        try (URLClassLoader newLoader = new URLClassLoader(new URL[]{url}, parent)) {
            Class<?> clazz = newLoader.loadClass("Main");
            Object o = clazz.getConstructor().newInstance();
            System.out.println("Class: " + o.getClass());
            System.out.println("Loader: " + o.getClass().getClassLoader());
            System.out.println("Instance of: " + (o instanceof Main));
            Main cls = (Main) o; //캐스트 실패
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- 동적 클래스로더를 정의할 때는 부모 클래스 로더에 주의해야한다.

## [044] StackOverflowError

재귀 호출은 스레드의 스택을 소모하기에 호출 단계가 지나치게 깊어지면 `StackOverflowError`가 발생한다.

- 재귀 호출이 스택 용량을 초과할 가능성이 있는지 확인한다. 
- 표준 알고리즘은 굳이 구현하지 않는다. 

## 총평

내용이 조금 어지러웠다. 그래고 캐스팅쪽은 확실히 도움을 좀 받았다.
책 하차할까










