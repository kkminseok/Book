## [045] char 값을 문자로 간주

👍 이런이모지들은 \ud83d + \ud84s 이런 코드포인트로 2바이트를 차지하게 되는데, 이런 문자열이 포함된 상태에서 `subString()`같은 연산을 사용하면 잘리게 되는 실수

- `codePointAt()`, `codePointBefore()`, ..과 같은 코드포인트용 API를 사용한다.
- `isDigit(char)`등의 라이브러리 메서드를 가급적 사용하지 않는다. 
- `BreakIterator`를 사용하는 것도 방법이다.

## [046] 대소문자 변환

로케일에 대한 얘기를 하는데, 터키어의 `i`의 대문자는 `I`가 아니니까 그런데서 로케일 오류가 발생할 수 있다는 얘기

- 터키어는 꼭 로케일 테스트해봐라..

## [047] 기본 로케일에서 String.format

`String.format`을 사용할 때 미국과 한국의 로케일은 소수점 구분자가 '.'인데, 몇몇 나라는 ','라는 것. 따라서 파싱시에 문제가 될 수 있다.

## [048] 포맷 인수 불일치

`String.format()`같은 함수를 사용할 때 인수의 자료형이나 갯수 불일치가 존재하는 경우를 말함.

- 유닛 테스트로 확인하자.
- 포맷 지정자가 참조할 인수를 명시적으로 지정한다.

## [049] 정규 표현식 대신 일반 문자열 사용

`foo.split(".")`;같은 문제를 말함. 이는 정규표현식으로 인식해서 빈문자열만 담긴 배열이 리턴된다.

- `foo.split("\\.")` 이렇게 적어서 해결할 수는 있다.

## [050] replaceAll 오용

`replace`대신 실수로 `replaceAll()`을 사용하는 경우가 존재.

replace는 단순한 리터럴을 받고, replaceAll은 정규표현식을 받는다.

```java
@Test
@DisplayName("replaceAll 메서드 실수 테스트")
void testReplaceAllMethodMistake() {
    String input = "$0minseok";
    String template = "Hello USER_NAME";
    String result = template.replaceAll("USER_NAME", input);
    Assertions.assertEquals("Hello USER_NAMEminseok", result);
}
```

이렇게 사용되는 경우가 문제이다. 정규표현식이 들어가면 의도와 다르게 동작할 수 있다.

- 정규 표현식이 필요하지 않을 때는 replace() 메서드를 쓴다.

## [051] 이스케이프 시퀸스 오용

```java
String foo = installbasePath + "\bin\tar.exe";
```

이런것처럼 파일 경로를 나타내려했으나 `\b`, `\t`라는 이스케이프 시퀸스로 바뀌어서 의도와 다르게 적용되는 문제

- 백슬래시는 신중하게 사용하자. 
- IDE에서 강조해주니까 실수할 위험이 좀 적을 수는 있을 것 같다.

## [052] 문자열의 대소문자 비교

```java
if(foo.startsWith("Each "))

//에서 뭔가 요구사항이 추가 되어서
if(foo.startsWith.toLowerCase(Locale.ENGLISH).startsWith("Each "))

//이렇게 변경되는 경우. 참인 경우가 없다.
```

- 유닛 테스트를 해보자.

## [053] indexOf 메서드 결과 미확인

`indexOf`메서드는 보통 `subString` 메서드와 함께 쓰이는데, indexOf가 찾는 문자가 없으면 -1을 리턴했을 때의 문제점을 말한다.

```java
int pos = foo.indexOf('='); // 못찾아서 -1리턴
entry.substring(0,pos).trim() // 이 경우 예외발생
```

이런 비슷한 경우에 대한 문제를 다룬다.

- 문자열을 못 찾았을 경우 대한 유닛 테스트를 진행한다.
- 적절한 서드파티 라이브러리를 이용한다.

## [054] IndexOf 인수 오용

`IndexOf`메서드는 첫 번쨰 인자가 **검색할 문자**, 두 번째 인자가 **검색을 시작할 인덱스**이다.

이런 경우에 두 인자 순서를 바꿔 적용하는 경우가 있는데, 이를 말함.

```java
int start = s.indexOf('[');
//... 로직들
int end = s.indexOf(start,']'); // 둘이 순서 바뀜.
```

```java
    @Test
    @DisplayName("indexOf 메서드 실수 테스트")
    void testIndexOfMethodMistake() {
        String input = """
                ]AAAAAAAAAA
                AAAAAAAAAA
                AAAAAAAAAA
                AAAAAAAAAA
                AAAAAAAAAA
                AAAAAAAAAA
                AAAAAAAAAA
                AAAAAAAAAA
                AAAAAAAAAA
                AAAAAAAAAA
                AAAAAAA[AA
                v
                """;
        int start = input.indexOf('[');
        int end = input.indexOf(start, ']');
        Assertions.assertEquals(118, start);
        Assertions.assertEquals(122,end);
    }
```

이런식으로 실수할 수 있다는 것이다.

- 유닛테스트 작성하자.

## 총평

다국어 내용과 정규표현식 조심해서 쓰자 라는 내용이 주로 이루어져 있는데, 

참고할만한 내용은 확실히 있었다. 기억할 수 있을까.