## [015] 잘못된 if-else 출력

- `if else`문 작성하다가 `else`를 빼먹는 경우
  - 이런 경우가 있나?;;
  - 변수 할당으로 따로빼거나 `final` 키워드를 이용하거나 등...


## [016] 이전 조건의 다음 조건 지배

```java
int age = 18;

if(age >= 6) {
    System.out.println("나이가 6이상");
// 밑의 수식은 실행될 일이 없음.
} else if(age >= 18) {
    System.out.println("나이가 18이상");
}
```

이런 조건식을 말함.

- 테스트 커버리지를 확인하여 어느정도 감지가 가능함.
- 주석을 통해 혼동을 줄인다.

## [017] switch문 통과 실수

`break`문장을 빼 먹은 경우를 의미.

```java
// Java14이상 제공하는 방식으로 해결 가능
switch(type) {
    case "door" -> System.out.println("door case");
    case "window" -> System.out.println("window case");
}
```

- switch 문의 모든 분기는 둘 중 하나의 형태로 통일
  - 무언가를 반환 (break문 없어도 됨.)
  - 하나의 변수를 할당 (`final` 키워드 사용)

## [018] 구형 for 루프 오류

for문 조건식 오타 등으로 인해 잘못 입력하여 무한 루프에 빠지는 경우에 대해 다룸

- 유닛 테스트를 진행하여 감지 가능

## [019] 루프 변수 미사용

```java
// types[i] 사용해야하는데, types[0]사용
String[] types = ...
...
for(int i =0; i< types.length; i++) {
    .... = ReflectUtils.forName(types[0]);
}
```

- `Arrays.setAll()`같은 함수를 고려
  - 람다로 쓰이기에 문제가 좀 더 눈에 띔
- 가급적 인덱스를 사용하지 않고, 스트림 API로 대체

## [020] 잘못된 루프 방향

```java
for (int i = hi - 1; i >= lo; i--)
```

위 코드를 수정하여 역방향 루프를 작성해야할 때 방향을 틀어줘야하는데, 그 과정속에서 발생하는 문제들을 말함.

- `reversed()` 함수를 사용하여 인덱스 사용을 하지 않음.
- IDE에서 제공하는 기능을 사용

## [021] 루프 오버플로

일반적인 조건식에서 `Integer.MAX_VALUE`나 `Long.MAX_VALUE`같은 조건식은 필요 없는지 검토가 필요하다는 뜻.

- `IntStream.rangeClosed(lo,hi)`같은 스트림 API를 사용
  - 오버 플로 값이 들어와도 해당 함수 내부에서 안전하게 처리함.

## [022] 멱등 루프 본문

루프를 잘못 작성해서 무한 루프를 도는 경우를 말함.

```java
// makeUniqueId("id", "id_1")은 무한루프
String makeUniqueId(String id, Set<String> usedIds) {
    int i = 1;
    String uniqueId = id;
    while(usedIds.contains(uniqueId)) {
        uniqueId = id + "_" + i;
    }
    return uniqueId;
}
```
위의 경와 같이 루프 내 멱등성이 존재하게 되어서 무한루프가 되는 경우를 말한다.

## [023] 잘못된 초기화 순서

### 정적 필드

```java

//CURRENT가 필요한 것들이 parse(), REGEX인데, REGEX는 CURRENT보다 늦게 선언되어 초기화 실패
public record Version(int major, int minor) {

    public static final Version CURRENT = parse(Application.getCurrentVersion());
    private static final Pattern REGEX = Pattern.compile("(\\d+\\.(\\d+))");

    static Version parse(String version) {
        Matcher matcher = REGEX.matcher(version);
        if(!matcher.matches()) {
            throw new IllegalArgumentException();
        }

        int major = Integer.parseInt(matcher.group(1));
        int minor = Integer.parseInt(matcher.group(2));

        return new Version(major, minor);
    }
}
```
- 복잡한 호출 과정은 초기화쪽에서 제거하도록 함.

### 서브클래스 필드

```java
public class Entity {
    private final int id;

    Entity() {
        id = generateId();
    }

    protected int generateId() {
        return 0;
    }

}

public class RandomIdEntity extends Entity{
    final Random random = new Random();

    @Override
    protected int generateId() {
        return random.nextInt();
    }
}
```

이런 경우 `RandomIdEntity`를 생서앟려고하면 `NullPointerException`이 발생한다.

슈퍼 클래스의 생성자 호출 이후, 서브 클래스 생성자가 호출된다.
슈퍼클래스 생성자가 실행될 때 하위 클래스 필드는 아직 초기화 되지 않은 상태인데, 오버라이딩한 `generateId()`함수는 random 필드가 이미 초기화되었다고 간주한다.

- 생성자는 가능한 한 단순하게 유지한다. 
- 중요한 초기화 로직은 생성자에서 뺀다.

### 클래스 초기화 순서

클래스 A와 B가 존재하는데 서로를 생성자에서 생성하려는 경우 -> 클래스 초기화 순환 문제

- 마찬가지로 초기화 로직은 단순하게 만든다

### ENUM 초기화 루프

위와 비슷함. 클래스가 아닌 Enum에서 발생하는 초기화 순환 문제

개인적으로 이 부분은 이렇게 짜는 사람이 있을까 싶었음. pass

## [024] 누락된 슈퍼클래스 메서드 호출

클래스를 상속한 상태에서 슈퍼클래스 메서드의 기능에 추가 로직을 보강해야할 경우

예를 들어서 `onKeyDown()`등의 메서드를 오버로드하는 방식으로 이벤트를 처리하고 있을 경우
서브클래스는 슈퍼클래스의 이벤트까지 같이 처리하는 경우

```java
public void onKeyDown(KeyEvent event) {
    super.onKeyDown(event);
    if (event.getKeyChar() == 'x') {
         //'x'키 기능
    }
}
```

반대의 경우로 **거부된 상속**이라는 의도적으로 서브클래스에서 슈퍼클래스의 일부 기능을 제거하는 상황이 있다. 이는 좋지 못한 코드이다.

명시적으로 슈퍼클래스 메서드를 호출해야하는데, 이는 누락되거나 제거되기도 쉽다.

- 구현 상속 메서드, 비추상임에도 오버라이딩 해야하는 메서드들은 인터페이스 구조로 설계하는게 나을 수 있다.
- 오버라이딩할 필요가 없는 중요 메서드들은 `final`로 선언한다. 

## [025] 우발적인 정적 필드 선언

실수로 `static` 키워드를 필드에 선언해버려서 모든 객체 사이에 공유되는 문제를 말함.

- final이 아닌 정적 필드 선언은 지양하도록 한다. 

## 후기

대부분의 휴먼 실수라서 조금 '??이렇게 하는 사람이 있다고? 그럴 수도 있겠구나.' 라고 생각하는게 많았다. 오타나 잘못된 복사,붙여넣기 등의 문제가 나타나는 것 같았다. 그래도 Java14에서 switch구문을 화살표로 간단하게 쓸 수 있다는건 배웠다.










