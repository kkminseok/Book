앞에서 동작파라미터화를 통해서 요구사항을 해결하는 것을 보았지만, 코드가 방대해져서 보기 불편하였다.

## 람다?

- 특징
    - 익명
    - 함수
    - 전달
    - 간결성

- 람다표현식 예제 종류에 대한 논의
- 람다는 함수형 인터페이스라는 문맥에서 사용이 가능

### 함수형 인터페이스

- 함수형 인터페이스 종류
    - Predicate, Runnable, Callable, ...

### 함수 디스크립터

- 람다 표현식의 시그니처를 서술하는 메서드. 예를 들어서 `Runnable` 인터페이스의 추상 메서드인 `run`같은 함수

한 개의 void 메소드 호출은 중괄호가 필요 없다.
ex) `process(() -> {System.out.println("test");});`

- `@FunctionalInterface`는 함수형 인터페이스라는 의미. 함수형 인터페이스가 아니라면 컴파일러 에러 발생. 또는 **한 개 이상의 추상 메서드가 존재하면** 에러 발생한다.

람다에 대한 예졔(내 블로그의 https://github.com/kkminseok/My-Spring-Test의 book 디렉터리 예제 참고)

## 함수형 인터페이스 사용

함수형 인터페이스의 여러 종류에 대한 논의
- Predicate, Consumer, Function

Java의 오토박싱을 해제할 수 있는 특화형 인터페이스들이 있다. `IntPredicate`, IntFunction<R>` ,....etc

## 형식 검사, 형식 추론, 제약

컴파일러가 어떻게 람다를 해석하는지에 대한 내용

1. 람다가 사용된 메서드의 정의 확인
2. 메서드 정의에 함수형 인터페이스가 있으면
3. 해당 함수형 인터페이스의 추상 메서드를 확인
4. 추상 메서드의 형식을 확인 후
5. 람다 표현식이 맞는 람다표현식인지(문법적으로) 반환값, 등등 잘 나타냈는지 확인

다이아몬드 연산자

- 앞의 `<>` 연산자를 통해 제네릭 형식을 추론할 수 있게함.

람다에 지역변수를 사용할 수 있지만, 이후 초기화할 수는 없다.

```java
@Test
@DisplayName("3.6 람다 지역변수 테스트")
void lambdaLocalVariableTest() {
    int num = 1;
    Function<Integer, Integer> function = (Integer i) -> i + num; //<- 밑에 num=2때문에 컴파일 에러
    System.out.println(function.apply(2));
    num = 2;
}
```

그 이유는 람다는 스택에 있는 지역변수를 직접 참조하지 않고, 값을 복사해서 자신이 만든 객체 필드에 저장하여 사용하는데 해당 변수는 `final`로 생성되어 값을 변경할 수 없게됨.
때문에 변경하려고하면 컴파일 에러남.

## 메서드 참조

메서드 참조를 만드는 방법

- 정적 메서드 참조
    - Intger의 parseInt는 `Integer::parseInt`로 표현 가능
- 다양한 형식의 인스턴스 메서드 참조
    - String의 length는 `String:length`로 표현 가능
- 기존 객체의 인스턴스 메서드 참조
    - CustomClass::getValue와 같이 커스텀된 내용


이후 책에서는 여러 함수형 인터페이스를 조합해서 사용하는 방법들을 나열하고 있다.

예를 들어서 `Predicate`에 있는 `and`, `negate`등의 메서드들을 말한다.

적분을 구현할 수도 있다.


## 총평

다시 읽으니 이해가 된다. 메서드 참조 문법은 더 익숙해져야겠지만 앞으로 계속 볼 터이니 괜찮을 것 같기도하다.