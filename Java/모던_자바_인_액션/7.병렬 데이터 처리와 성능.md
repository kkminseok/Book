병렬 스트림을 사용하여 성능을 더 올리는 방법에 대한 이야기.

병렬 스트림은 각각의 스레드에서 작업을 처리할 수 있도록 스트림 요소를 각 '청크'로 분할한 스트림

책에서 병렬 스트림 성능 측정은 **JMH**를 통해 이루어진다.

- 병렬 스트림으로 처리 못하는 경우가 있다. 예를 들어서 이전 값이 현재 값을 도출하는데 쓰이는 경우이다. 잘못 쓰면 오히려 느려질 수 있으니 이는 유의해야한다.
- 또 주의해야할 점은 **데이터 레이스**이다. 공유변수를 사용하면 문제가 발생할 수 있다.

### 효과적으로 병렬 스트림 사용하기

- 확신이 서지 않으면 성능 측정이 우선
- 박싱(boxing)연산 시간을 무시하면 안 된다. 되도록이면 특화 스트림(IntStream, ...)을 사용하자.
- 요소의 순서에 의존해야하는 경우 병렬 스트림이 더 느릴 수 있다.
- 소량의 데이터는 큰 이점을 못 볼 수 있다.
- 분해과정도 중요하다. 모든 요소를 탐색해서 분리해야하는 `LinkedList`보다 `ArrayList`를 사용하면 효과적으로 분할할 수 있다.
    - ArrayList: 훌륭
    - LinkedList: skQma
    - IntStream.range: 훌륭
    - Stream.iterate: 나쁨
    - HashSet: 좋음
    - TreeSet: 좋음

이후 책에서는 포크/조인 프레임워크에 대해서 다루고 있다. 분할 정복이랑 같은 알고리즘이라고 파악하면 될 것 같다.

분할 하여 CPU가 할당되어 각 작업을 처리할 떄 여러 요인에 따라 어떤 작업이 먼저 완료될 수 있는데, 포크/조인 프레임워크에서는 작업을 포함하는 이중 연결 리스트를 참조해서 먼저 끝난 작업이 있으면 유휴상태에 들어가지 않고, 다른 작업을 떼와서 시작한다.

-----

`Spliterator` 인터페이스는 스트림을 자동으로 분할해준다.

```java
public interface Spliterator<T> {
    boolean tryAdvance(Consumer<? super T> action);
    Spliterator<T> trySplit();
    long estimateSize();
    int characteristics();
}
```

- tryAdvance: 요소를 하나씩 순차적으로 소비하면서 탐색해야 할 요소가 남아있으면 참을 반환
- trySplit: Spliterator의 일부 요소를 분할해서 두 번째 Spliterator를 반환하는 생성하는 메서드
- estimateSize: 탐색해야할 요소 수 정보
- characteristics: Spliterator 자체의 특성 집합을 포함하는 Int 반환
    - ORDERED: 요소에 정해진 순서가 있으므로 분할,탐색시 이 순서에 유의해야 한다.
    - DISTINCT: x,y 두 요소를 방문했을 때 x.equals(y)는 항상 false를 반환
    - SORTED: 탐색된 요소는 미리 정의된 정렬 순서에 따른다.
    - SIZED: 크기가 알려진 소스(ex: Set)로 Spliterator를 생성했으므로 `estimatedSize()`는 정확한 값을 반환한다.
    - NONNULL: 탐색하는 모든 요소는 null이 아니다.
    - IMMUTABLE: Spliterator는 불변이다. 요소를 탐색하는 동안 요소를 추가허간, 삭제하거나, 고칠 수 없다.
    - CONCURRENT: 동기화 없이 Spliterator의 소스를 여러 스레드에서 동시에 고칠 수 있다.
    - SUBSIZED: 이 Spliterator 그리고 분할되는 모든 Spliterator는 SIZED속성을 가진다.


### 분할 과정

`trySplit()`를 호출하면 새로운 Spliterator가 생기는데 메서드의 값이 null이 될 때까지 새로운 Spliterator을 생성해낸다. 

책의 뒤는 커스텀한 Spliterator를 만드는데, 확인하고 넘어갔다.

## 총평

저번에 읽을 때는 이쯤에서 막혔던 것 같다. 분할은 어렵기도하다. 그리고 잘 본적도 없고해서 완벽히 숙지하기에는 더 어려웠던 것 같다.

배워가야할건 항상 병렬이 정답은 아니고, 직접 제어할 때는 많은 제약조건들을 설정 해줘야한다는 것이다.

