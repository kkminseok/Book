이번장에서는 스트림 연산중 최종연산에 대해 살펴본다.
앞에서는 `toList()`로 결과 데이터를 반환하는 것만 보았는데, 다른 방식들도 보여줄 예정이라고 한다.

- 컬렉터를 통하여 스트림의 항목을 컬렉션으로 재구성할 수 있다.
- 분할 함수는 맵의키를 true,false 두 개만 가지므로 맵의 종류는 2개다.


-----

Collector 인터페이스 정의


```java
public interface Collector<T, A, R> {
    
    Supplier<A> supplier();

    
    BiConsumer<A, T> accumulator();

    BinaryOperator<A> combiner();

    Function<A, R> finisher();

    Set<Characteristics> characteristics();
}
```

- T는 수집될 스트림 항목의 제네릭 형식
- A는 누적자. 수집 과정에서 중간 결과를 누적하는 객체의 형식
- R은 수집 연산 결과 객체의 형식(대게 컬렉션 형식)

커스텀하려면 밑의 함수들을 오버라이드해줘야함.

### supplier 메서드: 새로운 결과 컨테이너 만들기

### accumulator 메서드: 결과 컨테이너에 요소 추가하기

```java
public BiConsumer<List<T>, T> accumulator() {
    return (list,item) -> list.add(item);
}
```


### finisher 메서드: 최종 변환값을 결과 컨테이너로 적용

```java
public Function<List<T>, List<T>> finisher() {
    return Function.identity();
}
```

### combiner 메서드: 두 결과 컨테이너 병합

```java
public BinaryOperator<List<T>> combiner() {
    return (list1, list2) -> {
        list1.addAll(list2);
        return list1;
    }
}
```

### Characteristics 메서드

스트림을 병렬로 리듀스할 것인지, 병렬로 리듀스 한다면 어떤 최적화를 선택할 지 힌트를 제공.

- UNORDERED: 리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향 받지 않음.
- CONCURRENT: 다중 스레드에서 accumulator 함수를 동시에 호출 가능. 병렬 리듀싱 가능.
- IDENTITY_FINISH: finisher 함수가 반환하는 함수는 단순 identity를 적용할 뿐 이므로 이를 생략할 수 있도록 함.


구현 하지 않고 커스텀 컬렉터를 만들 수는 있다. 

