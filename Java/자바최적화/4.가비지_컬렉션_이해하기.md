- 옛날과 달리 가비지컬렉션 많이 발전했다.
- 가비지 컬렉션은 2가지 기본 규칙을 준수하려고 노력한다.
    - 활성 객체는 절대 수집되지 않아야 한다.(가장 중요))
    - 알고리즘은 모든 가비지를 수집해야 한다.

## 마크 앤 스윕

- 동작방식
할당됭 객체 리스트를 사용하여, 회수되지 않은 객체들의 포인터를 유지하는 방식으로 동작
1. 할당된 리스트를 순회하며 마크 비트를 초기화함.
2. 힙으로의 모든 포인터를 시작점으로 하여 접근 가능한 모든 객체를 찾음.
3. 도달한 각 객체에 마크 비트를 설정함.
4. 할당된 리스트를 순회하며, 마크 비트가 설정되지 않은 객체에 대해 다음 작업을 수행
  - 힙에서 해당 객체의 메모리를 회수하여 자유 리스트에 다시 추가
  - 객체를 할당된 리스트에서 제거

## 가비지 컬렉션 용어

- STW(StopTheWorld): 가비지 컬렉션이 진행되는 동안 모든 애플리케이션 스레드를 멈춰야함. 애플리케이션 코드가 가비지 컬렉션 스레드가 보는 힙 상태를 무효화하지 않도록 방지
- 동시성: 애플리케이션 스레드가 실행되는 동안에도 가비지 컬렉션 스레드는 동작할 수 있다. 구현이 더 어렵다. 자바9부터 기본 가비지 컬렉터는 **G1**이며 일부 동시성 측면을 가지고 있다.
- 병렬
- 정확성  
.. 나머지는 알만한 내용이라 정리 x

## 핫스팟 런타임

자바의 특징에 대해 인지해야할 것이 있다. 자바의 메서드 호출은 **값-복사**방식으로 이루어지며 역참조 개념이 없다는 것이다.

## 할당과 수명 주기

자바 애플리케이션의 가비지 컬렉션 동작을 결정하는 두 가지 주요 요인

- 할당 속도: 일정시간동안 새로 생긴 객체가 사용하는 메모리의 양
- 객체의 수명 주기: 말그대로 객체의 수명 주기. 근데 이를 측정하거나 추정하기는 매우 어렵다. 

## 약한 세대 가설

객체의 수명이 대부분 짧은 반면, 일부 객체는 훨씬 더 긴 수명을 가지는 경향이 있다는 것. 이는 힙이 두 개의 별도 영역, 짧은 수명의 영역과 긴 수명의 영역을 가져야 하며, 각각 **젊은**컬렉션과 **전체** 컬렉션에서 별도로 수집되어야 한다는 것을 의미한다.

주요 기술 중 하나는 최근 생성된 객체가 있는 영역(Eden이라 불림)에 마크 앤 스윕 컬렉션을 사용하는 것이다. 에덴영역에서 긴 수명을 가진 객체를 긴 수명의 공간으로 이동 시킨 후 메모리를 전체적으로 회수하는 것이다.

## 핫스팟의 프로덕션 가비지 컬렉션 기술

할당 성능을 개선하기 위해 사용되는 핵심 기술

### 스레드-로컬 할당

에덴은 힙의 영역 중 대부분의 객체가 생성되는 영역이고, 이 영역을 잘 다뤄야 성능에 긍정적인 영향을 미칠 수 있다. 할당 효율성을 개선하기 위해 에덴을 여러 개의 버퍼로 분할하고, 각 애플리케이션 스레드에 독립적인 에덴 영역을 할당하여 새 객체를 생성하도록 한다. 이 방식의 장점은 각 스레드가 자신에게 할당된 버퍼에서만 작업하므로, 다른 스레드가 동일한 버퍼에서 할당 작업을 수행하는 것을 걱정할 필요가 없다. 이러한 영역을 **스레드-로컬 할당 버퍼(TLAB)**라고 한다. 이 방식을 사용하면 객체 할당이 O(1) 시간 복잡도로 이루어진다는 것을 의미한다. 스레드가 새 객체를 생성할 때, 해당 객체를 위한 저장 공간이 할당되고 스레드 로컬 포인터가 다음 포인터를 다음 사용 가능한 메모리 주소로 업데이트 되기 때문이다.
이런 방식으로 인해 애플리케이션 스레드가 현재 스레드-로컬 할당 버퍼를 모두 채우면 자바 가상 머신은 에덴의 새로운 영역을 할당하며, 해당 버퍼에 대한 포인터를 제공한다.

### 반구형(Semi-space) 컬렉션

힙 메모리를 **두 개의 동일한 크기의 영역으로 나눠서**, 하나는 사용하고, 다른 하나는 비워두는 방식.
- 메모리 공간을 from-space와 to-space로 나눔
- from-space에 객체를 생성하여 동작함.
- GC가 발생하면 살아있는 객체만 to-space로 복사
- 복사가 끝나면 역할을 바꿈 (to-space -> from-space, from-space -> to-space)

위 스레드 로컬, 반구형 컬렉션을 혼합해서 GC를 일으키는데, 이를 **영역 기반 컬렉터**라고 한다. 

## 병렬 컬렉터

자바 8 또는 이전 버전에서 자바 가상 머신의 기본 가비지 컬렉터.

STW이후 활성 객체를 빠르게 식별하기 위해 여러 스레드를 사용하도록 설계됨. 

### 일반 병렬 컬렉터

객체를 할당하려고 할 떄 스레드-로컬 할당 버퍼에 충분한 공간이 없고, 새 스레드-로컬 할당 버퍼를 할당 할 수 없을 때 발생. 애플리케이션 스레드를 모두 중지시키고 에덴 영역과 현재 비어있지 않은 서바이버 영역을 확인하고, 가비지가 아닌 객체를 식별하여 비어있는 서바이버 영역으로 이동시킨다.(객체의 세대 카운트를 증가시킴)

### 오래된 병렬 컬렉션

Parallel Old 컬렉터라 불리며, 자바 8까지의 기본 컬렉터였다.
단일 연속 메모리 공간을 사용하는 압축형 컬렉터이다. 오래된 객체가 소멸하며 남겨진 공간을 회수하기 위해 오래된 세대 내에서 객체를 재배치한다. 

### 직렬, SerialOld

단일 CPU 코어만 사용함. 병렬 가비지 컬렉션은 아님. 멀티코어 시스템에서는 이 컬렉터는 매우 비효율적으로 동작함. STW가 발생하고 작업하는 동안 나머지 CPU는 모두 idle상태가 되어버림.

### 병렬 컬렉터 한계

병렬 컬렉터애서 동작하는 마킹 소요 시간은 활성 객체의 수에 비례한다. 에덴 영역에 있는 객체들을 마킹하는데 많은 시간이 소요되지 않지만 Old영역에 있는 객체들을 마킹하는데에는 많은 시간이 소요될 수 있다. 애초에 Old영역은 에덴영역보다 크기가 7배정도 크며, **영구 수명을 지닌 객체들이 존재할 수도 있기에 이를 매 번 수집하기에는 부담이 생길 수 밖에 없고**, 이게 병렬컬렉터의 단점이라고 할 수 있다.

또한, 스레드-로컬 할당(Thread-Local Allocation Buffers, TLABs) 을 활용한 메모리 관리 전략은 직접 스레드를 생성하거나 Executor가 아닌 로우 레벨 스레드를 사용할 경우 TLAB 최적화가 제대로 적용되지 않을 수 있다.

## 할당의 역할

가바지 컬렉션은 규칙적으로 동작하는게 아니다보니 여러 자원들이 어떻게 할당되는지가 중요하다. 다음 사례를 통해 그 이유를 알 수 있다.

- 전체 힙 : 2GB
- 오래된 세대: 1.5GB
- 젊은 세대: 500MB
- 에덴 공간: 400MB
- 서바이버 공간: 50MB
- 서바이버 공간2: 50MB

- 할당속도: 100MB/s
- 젊은세대 가바지 컬렉션 시간: 2ms
- 전체 가비지 컬렉션 시간: 100ms
- 객체 수명 주기: 200ms

이럴때 에덴 공간에 4초만에 공간이 차게되고 GC가 발생하게 되어있다. 여기서 3.8 ~ 4초 사이에 생성된 객체는 객체 수명주기를 다하지 않아서 GC대상이 되지 않고 서바이버 1(SS1)영역으로 넘어갈 것이다.

이렇게 된 뒤 또 4초가 흐르면 SS2영역으로 7.8초~8초 사이에 생성된 객체들이 이동하게 될텐데 SS1에 있던 객체들은 이미 수명을 다해서 사라져있을 것이다. 그리고 4초가 지나면 이러한 패턴이 반복될 것이다. 이렇게되면 그 어떤 객체도 오래된 세대로 승격되지 않으며, 실행 내내 오래된 세대 공간이 비어있게 된다. 물론 실제 힙 공간을 저렇게 지정해서 동작하진 않는다. 하지만 이렇듯 가비지컬렉터가 규칙적으로 동작하지 않기에 객체 할당 속도가 중요한 것이다.

가바지 컬렉터는 할당 속도가 높아질수록 가비지 컬렉션은 더 자주 발생하고, 할당 속도가 지나치게 높을 경우 객체가 조기에 승격되는 상황이 발생한다.(조기 승격, 많은 튜닝의 시작점)


## 후기

책에 그림이 어느정도 있지만 메모리영역에 대해서 머릿속으로 어느정도 그려야한다. 가바지 컬렉션은 중요한만큼 집중해서 머릿속에 그림을 그렸던 것 같다. 내용자체는 이해하기 나름 쉬웠던 것 같다? 이해가 어려운 부분은 검색해서 찾아보긴 했다. 하지만 찾기 어렵지는 않다.

이처럼 특정 부분은 설명이 부족한 곳이 있다. 세대 카운트라는 용어 설명이 없었는데, 갑자기 뒤에서는 쓰이고 있고 이런거? 이런거는 본인이 직접 찾아가면서 학습해야할 것 같다.

그리고 너무 한국어에 집착?하는 것 같았다. 사실 Parallel Old GC가 '오래된 병렬 컬렉터' 라는 말보다 더 친숙한데 이를 한국어로 그대로 넣으니까 오히려 '뭐지?'라고 생각하게 된다.





