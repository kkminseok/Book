- 하드웨어에 대한 내용

과거, CPU의 성능이 올라가면서 메모리의 발전 속도가 이를 따라가지 못하는 상황이 발생했고 이에 맞춰서 **CPU 캐시**가 도입되었다. CPU와 가장 가까운 캐시부터 L1,L2,L3의 레이어를 가진다. 이 방법을 통해 CPU가 원하는 데이터 접근시간을 제공할 수 있게 되었다. 이런 과정중 프로세스 끼리의 캐시 동기화 문제가 발생하였다.

캐시에서 제공하는 프로토콜로 **MESI프로토콜**이 존재하는데,캐시에 저장된 데이터의 네 가지 상태를 정의한다.

- 수정: 수정되었지만 아직 주 메모리로 반영되지 않은 상태
- 단독: 현재 캐시에만 존재하며 주 메모리와 일치하는 상태
- 공유: 다른 캐시에도 존재할 수 있는 상태로, 주 메모리와 일차함.
- 무효화: 사용 불가능한 상태, 가능한 한 빨리 삭제될 상태

여기서의 문제는 한 프로세서가 단독 또는 수정 상태로 전환되면, 다른 모든 프로세서는 강제로 무효화 상태를 가지게 된다. 공유 메모리 버스를 통해 전기 신호를 발생하여 다른 프로세서들에게 변경 사항을 알린다.

초기에는 프로세서가 모든 캐시 작업을 주 메모리에 직접 기록했는데, 이를 **동기식 쓰기**라고 한다. 매우 비효율적이고 주 메모리에 대해 대규모 대역폭을 요구했다.
이후 **쓰기 반영**이라는 동작을 구현하게 되었다. 이는 수정된 캐시 블록만 주 메모리에 기록하도록 하여 주 메모리로의 트래픽을 크게 줄였다. 

## 현대 프로세서의 특징

- TLB(Translation Lookaside Buffer)라는 캐시 메모리를 통해 가상 메모리 시스템에서 가상 주소 -> 물리 주소 변환을 빠르게 처리하고 있음.
- 분기예측과 추측 실행을 통해 성능 향상을 진행
    - 분기예측: 말그대로 조건문과 같은 분기에서 **파이프라인을 멈추지 않고** 유지하기 위해 분기를 예측함.
    - 추측실행: 분기를 예측하면 이를 기준으로 명령어들을 실행하는 것을 의미함. 만약 예측이 실패한 경우 롤백함.
    - 대체로 효과적
- 하드웨어 메모리 모델
    - 멀티코어 시스템에서 어떻게 여러 CPU가 동일한 메모리 위치를 어떻게 일관되게 접근 할 수 있는가에 대한 질문에 대한 고민들(일관성). 하드웨어에 따라 크게 다름.
    - 이를 보장하려면 올바른 잠금과 여러 동기화 관련 키워드를 올바르게 사용하는게 중요함.

## 운영체제

### 스케줄러

프로세스 스케줄러는 CPU 코어에 대한 접근을 관리하고 인터럽트에 대응한다.

**실행 대기 큐**라는 대기역역을 사용하며, CPU를 사용하기 위해 순서를 기다려야하는 
**플랫폼 스레드**를 보관하는 공간이다. 

스케줄러는 이러한 작업을 담당하는데, 각 스레드마다 시간 할당량을 제공하고 할당량이 끝나면 다시 대기 큐의 끝으로 보내고 순서가 오면 실행시키는 것을 반복한다.

sleep(), wait()같은 함수로 스레드를 대기시킬 수도 있고, I/O작업으로 인해 차단될 수도 있다. 여기서 중요한 점은 지연시간이 있다. 스레드마다 각 주어진 시간 할당량을 채우면 다시 큐의 끝으로 가고 다시 실행되는 구조다보니, 실제로 0.1초씩 Sleep을 1000번 걸어도 100초를 기다리는것이 아닌 100초 이상을 기다리게 된다. 


### 자바 가상 머신과 운영체제

자바에서 스레드 스케줄러나 시스템 시간 등을 가져오려면 시스템 콜을 사용해서 가져와야한다. 자바에서는 네이티브 메서드를 통해 제공되며, **native**키워드로 표시된다. 네이티브 메서드는 C언어로 작성되었지만 자바 네이티브 인터페이스(JNI)를 통해서 호출이 가능하다. 즉, 자바에서 `System.currentTimeMils()`같은 함수를 호출하면
```text
Java: System.currentTimeMillis() -> C: JVM_CurrentTimeMillis() -> C++: OS::javaTimeMills()
```

순으로 호출되어 운영체제에 접근할 수 있게 된다.

### 컨텍스트 스위치

**컨텍스트 스위치**는 운영체제 스케줄러가 현재 실행 중인 플랫폼 스레드를 제거하고 다른 스레드로 교체하는 과정이다. 컨텍스트 스위치는 사용자 스레드 간 또는 사용자 모드에서 커널모드로 변환될 때 발생되는데, **후자의 경우 상당한 비용을 소모하게 된다.** 과정중에 사용자 공간과 커널 공간은 주소 공간이 분리되어 있어, 커널 모드 진입 시 CPU의 TLB나 캐시가 무효화되거나 플러시될 수 있기 때문에 명령어 캐시와 기타 캐시를 비우는 작업이 있기 때문이다. 

컨텍스트 스위칭 비용을 줄이기 위해, 리눅스는 **가상 동적 공유 객체(vDSO)**라는 메커니즘을 제공한다. 사용자 공간 내 메모리 영역에 위치해있고, 커널 권한이 필요하지 않은 시스템 호출들을 최적화된 메모리 맵을 통해 수행하여, 컨텍스트 스위치를 진행하지 않아 성능을 올릴 수 있게 한다. 

## 간단한 시스템 모델

### CPU 활용

CPU에 의존적인 애플리케이션은 높은 부하 상태에서 가능한 한 100%에 가까운 CPU 사용률을 목표로 해야한다. 성능을 파악하기 위한 세 가지 도구를 책에서 소개하고 있다.

- vmstat: 가상 메모리 통계를 보고, 메모리 크기, I/O, 접근과 관련된 정보를 제공
- ifstat: 네트워크 인터페이스 통계 제공
- iostat: 디바이스 입력/출력을 모니터링

### 가비지 컬렉터

가비지 컬렉터는 메모리가 시작 시 할당되고 사용자 공간에서 관리되기에 컨텍스트 스위칭이 잘 일어나지는 않는다. 때문에 CPU 사용량이 높다해서 GC의 문제는 아닐 수 있는데 사용자 공간에서 CPU 사용량이 높다면 GC로 인한 문제 일 수도 있다.


## 총평

하드웨어에 대한 개념은 환기 시켜줘서 좋았다. 용어에 대한 설명이 부족하면 GPT와 함께 공부하면서 하니까 낫더라. 그래도 뒤의 내용이 점점 궁금해진다.