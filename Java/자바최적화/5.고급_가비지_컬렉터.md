현대에서 자주 사용되는 가비지컬렉터에 대한 이야기

- G1GC
- ZGC
- Balanced
- 섀넌도어
...

이런 가바지컬렉터가 대거 등장한 이유는 가비지 컬렉터가 가진 특성들이 있기 때문이다.
트레이드오프를 지니고 있는데, 가비지 컬렉터에 소요되는 시간을 줄이면 애플리케이션의 성능이 저하될 수도 있고 압축을 진행하여 메모리 접근속도를 높이면 가비지 컬렉터에 소요되는 시간이 늘어나고.. 이런 것들이 있다. 모든 것들을 충족할 수는 없으며 각각 우선순위에 따라 다양한 가비지 컬렉터를 선택하면 되고, 각 가비지컬렉터가 어떤 장점을 지니고 있는지 확인하면 된다.

## 자바 가상 머신 세이프포인트

STW가 발생하면 애플리케이션 스레드를 중지해야하는데, 이는 가비지컬렉션이 직접하지는 않고 내부에서 실행되는 애플리케이션 스레드가 협력하여 중단하게 된다.

1. 자바 가상 머신이 전역적으로 '세이프포인트로 진입할 시간' 플래그를 설정
2. 개별 애플리케이션 스레드가 이 플래그를 감지하고 설정된 시간인지 확인
3. 스레드가 중단된 후 다시 깨울 때까지 대기

애플리케이션 스레드는 위 목적을 달성하기 위해 폴링방식을 사용하며 이런식으로 스레드가 멈추게 된다. 

가비지 컬렉션 내부 동작은 다음과 같은 **삼색 마킹**이라는 방식으로 진행된다.

- 가비지 컬렉터 루트는 회색으로 표시됩니다.
- 다른 노드(객체는) 흰색으로 표시됩니다.
- 마킹 스레드는 무작위로 회색 노드를 선택함.
- 선택된 노드에 흰색 자식 노드가 없으면, 해당 노드는 검은색으로 변경됨.
- 반대로 흰색 자식 노드가 있다면, 마킹 스레드는 해당 자식 노드를 회색으로 변경한 후 탐색을 계속함.
- 이 과정을 회색 노드가남지 않을 때까지 반복
- 검은색 객체는 도달 가능한 것으로 판명되어 수집하지 않음.
- 반면, 흰색 노드는 도달할 수 없는 객체로 간주되어 가비지 컬렉션의 대상이 됨.

![](./img.png)
출처: https://www.google.com/imgres?q=%EC%82%BC%EC%83%89%EB%A7%88%ED%82%B9&imgurl=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FB3Ma8%2FbtssCt7uEaq%2FOgKzGudSi6DaprkKYCXiR1%2Fimg.png&imgrefurl=https%3A%2F%2Fgksdudrb922.tistory.com%2F297&docid=XYcvc87nvkADUM&tbnid=6oQ6llmI0uBaeM&vet=12ahUKEwjF7JLu__eNAxWse_UHHRXVDOsQM3oECGoQAA..i&w=1280&h=687&hcb=2&ved=2ahUKEwjF7JLu__eNAxWse_UHHRXVDOsQM3oECGoQAA


위 알고리즘을 사용하는 컬렉터는 실행 중인 애플리케이션 스레드에서 변경된 객체가 잘못 수집되지 않도록 추가적인 처리가 필요함. 이를 해결하기 위한 여러 방법들이 존재하고 그 중 G1이 사용하는 리마크 방법이 있다.


### 포워딩 포인터

각 객체에 추가적인 메모리 공간을 사용하여 해당 객체에 이전 가비지 컬렉션 단계에서 재배치 되었는지 여부를 나타내고, 객체의 새로운 위치를 가리키는 정보를 제공한다.

예시

1.	객체 A가 Eden 영역에 있음.
2.	객체 A가 살아있으므로 SurvivorTo로 복사.
3.	Eden의 객체 A 자리에 “나는 새 주소는 0x1234야” 라는 포워딩 포인터를 남김.
4.	객체 B가 객체 A를 참조하고 있다면:
    - B가 A를 따라가면 포워딩 포인터가 있음.
    - GC는 포워딩 포인터를 따라 새 주소(0x1234)로 연결 갱신.


이런식으로 객체들을 연결하여 추적한다.

여기에는 명확한 단점이 있는데, 객체당 하나의 메모리 단어가 추가로 필요하여 공간에 대한 오버헤드를 초래한다. 이 기법은 실제 셰넌도어와 같은 고급 컬렉터에서 사용되며, 문제를 해결한 방식도 뒤에 나온다고 한다.

## G1 GC

자바 8 이후 버전에서 핫스팟 가상 머신의 기본 가비지 컬렉터이다.

- 가장 핵심 개념은 **일시 정지 목표**
    - 개발자는 GC주기마다 일시 정지해야 하는 최대 시간을 설정할 수 있음. 기본값은 200ms이지만 보통 더 빠르게 끝나므로 기본값만 써도 충반함. 매우 큰 힙을 가진 경우에는 조절이 필요할 수 있다.
- 기존과 달리 힙은 고정 크기의 영역 개념을 기반으로 하고, 이를 모여 **세대**를 구성함. 
- 자바 21부터 G1의 알고리즘은 2의 제곱 MB크기의 영역을 허용함.(최대크기 512MB)
- 기본적으로 G1은 힙에서 2,048에서 4.095개의 영역을 기대하며, 이를 달성하기 위해 영역 크기를 조정함.
- 애플리케이션에서 영역크 크기의 절반보다 큰 객체를 생성하는 경우, 이는 humongous 영역에 직접 할당됨. 

- 컬렉션은 2가지 유형의 컬렉션이 존재
    - 젊은 세대 컬렉션
        - 가능한 한 빨리 힙을 회수하려고 하는 STW 컬렉션
    - 혼합된 세대 컬렉션
        - 젊은 세대 컬렉션으로 커버가 안 될 경우 사용됨.
        - 오래된 객체를 회수하고 자유 영역의 수를 늘리기 위한 작업을 진행함.
        - 코어 중 일부만 사용해서 컬렉션을 실행하고 나머지는 코드를 실행하게함. 때문에 애플리케이션 처리량이 감소할 수 있다.

G1 Old에는 네 가지 단계가 있다.

1. 동시 시작(STW G1 New 포함)
2. 동시 마킹
    - 일반적으로 가장 오래 걸림.
3. 재마킹(STW): 동시 마킹 후 여전히 살아있는 객체를 수집하지 않도록 기록을 수정하는 단계
4. 클린업(STW): 완전히 비워져 재사용할 준비가 된 영역을 식별하는 회계 작업을 진행

ParallelOld에서는 카드 테이블 메커니즘을 사용해 객체 참조들을 추적하였는데, G1에서는 **기억 집합(RSet)**을 통하여 추적한다. 기억집합을 통해서 전체 힙을 추적하지 않고 해당 영역을 스캔해서 참조를 찾으면 되는데, 문제는 부유 가비지라는 현상이 벌어질 수 있다.
부유 가비지란 살아있는 객체를 잘못 식별해서 이미 죽은 객체가 계속 살아남게 되는 문제가 발생하는 것을 의미한다. 이러한 문제를 해결하기 위해서 클린업 단계 동안 G1은 기억 집합 '세척'작업을 수행한다. 이 과정을 통해 비워진 영역으로 포인팅하던 영역의 기억 집합을 검사하고, 다른 영역으로 이동된 객체에 대한 참조를 업데이트 한다.

Full GC(전체 컬렉션)은 STW방식으로 수행되며, 힙 전체를 정리한다. 여러가지 이유로 실행될 수 있지만 그 중 하나는 거대한 영역의 단편화가 존재할 때 한다. 또 다른 가능성은 혼합 컬렉션 중 동시 마킹 단계가 애플리케이션이 사용 가능한 힙 메모리를 모두 할당하기 전에 완료되지 못하는 경우이다. 일반적으로 초기 힙 점유율 비율 임계값은 이러한 상황이 벌어지지 않도록 동적으로 설정된다. 



**다른 주의할 점은 현대 자바 버전에서는 G1을 활성화하기 위한 설정이 필요없지만, 컨테이너 환경에 코어1개만 사용하고 있을 경우 G1이 실행되지 않고 직렬 컬렉터로 대체될 수 있다.** 



## 셰넌도어

레드햇이 OpenJDK프로젝트 내에서 만든 G1의 대안이다. 자바 17,21에서 완전히 지원되는 컬렉터

셰넌도어의 목표는 대용량 힙에서 **동시압축**을 통해 일시 정지 시간을 줄이는 것이다. 이러한 목표를 달성하려다보니 보통 G1보다 더 많은 CPU자원을 사용하게 된다.

다음과 같은 순서로 GC가 이뤄진다.

1. 초기마킹
2. 동시 마킹
3. 최종 마킹
4. 동시 클린업
5. 동시 이동
6. 초기 참조 업데이트
7. 동시 참조 업데이트
8. 최종 참조 업데이트
9. 동시 클린업

셰넌도어는 애플리케이션 스레드와 가비지 컬렉션 스레드가 동시에 실행되며 메모리를 관리하는 구조다. 애플리케이션 스레드가 실행되면서 빠르게 많은 객체를 생성하고 사라지게 하는 동안, 가비지 컬렉션 스레드는 동시에 비우기를 시도한다. 이 두 스레드는 일종의 속도 경쟁을 하게 되며, 가비지 컬렉션이 객체 할당 속도를 따라잡을 수 있다면 비우기가 가능해진다. 반대로, 할당 속도를 따라잡지 못하면 비우기를 수행할 수 없는 상태가 된다.

셰넌도어는 대용량 힙에서 사용될 수 있도록 설계되었다보니 범용성이 크지는 않다.

## ZGC

ZGC의 목표는 힙 크기나 메타스페이스 크기에 따라 확장되는 모든 가비지 컬렉션 작업을 STW단계에서 제거하고 동시단계로 이동시키는 것이다.

> 보충 설명: 힙 크기나 메타스페이스 크기가 커지면 GC가 멈추는 시간도 커지기에 GC의 많은 작업(마킹, 정리, 캠팩션 등)을 애플리케이션과 동시에 실행해서 STW 시간 자체를 없애는게 목표. 따라서 힙 크기가 아무리 커져도 GC로 인해서 애플리케이션이 멈추는 시간을 거의 생기지 않도록 함.

ZGC는 다음과 같은 특징을 가진다.

- 동시
- 영역 기반
- 압축
- 비균일 메모리 접근(NUMA)
- 컬러 포인터 사용
- 로드 장벽 사용

G1, 셰넌도어와 비슷한 점도 있지만 **컬러 포인터**라는건 ZGC만 가지고 있는 특징이다. 객체 포인터나 oop 자체에 객체 수명 주기에 대한 추가 메타데이터를 저장한다. 이 메타데이터는 객체가 살아 있는지 여부와 주소가 올바른지를 나타낸다.

> 색상만 보면 되므로 GC가 별도의 맵이나 테이블 없이 객체 상태를 실시간으로 파악할 수 있다.

```text

 [ 포인터(64비트 중 일부) ]

 ┌──────────────────────────────────────────┐
 │   0x0000...1234ABC0 (Ref to Obj A)       │
 │     ↑↑↑                                  │
 │     │││──► 색 정보 (ex: Marked, Remapped)│
 └──────────────────────────────────────────┘

	•	White: 아직 방문 안 함
	•	Gray: 방문했지만 내부 필드(참조)는 미처리
	•	Black: 방문 완료 및 모든 내부 참조 처리
	•	Remapped: 포인터가 새 위치로 바뀜
```

자바21에서는 새로운 버전의 ZGC, **세대별 ZGC**가 등장하였다. 젊은 세대 가비지컬렉션을 도입해서 할당 속도에 대한 영향을 최소화하였다. 또한, 기존에는 다중 매핑 메모리 구조를 사용하다보니 메모리 사용량을 과다 보고할 수 있는 환경이 구성되었는데, 세대별 ZGC는 대신 메모리 장벽에서 명시적인 코드를 사용하여 문제를 피한다. 컬러 포인터에 대한 접근 방식도 다른데, 12비트의 색상비트를 사용하며 이전에 4비트를 사용하던 것과 차이가 있다.

> 핵심은 짧게 쓰이고 버려지는 객체도 너무 무겁게 처리해서 개선했다는 것. 다중 매핑 기법이란 동시에 여러스레드가 메모리를 읽고 쓸 수 있도록 하였음. 때문에 운영체제가 메모리를 많이 사용중인 것처럼 보고하게됨. JVM이 CPU에게 "이 시점까지 메모리 쓰기/읽기를 정리하라"고 명령하는 코드를 사용해서 동시성 안정을 유지하고 메모리 낭비를 줄이는 방법이 "명시적 메모리 장벽"이다. 색상 컬러 비트 늘어난건 세대별 구조 도입으로 더 많은 상태 정보가 필요하여 도입되었다. 책의 내용만으로 이해하기 어려워서 추가로 찾아본 내용이다.

책 뒤에는 BalancedGC(Open9 JVM), 동시 마크 스윕 컬렉터, 엡실론 컬렉터 등이 나오지만 사실상 성능이 좋지 G1, ZGC등에 비해 좋지 않아서 시장되어 사용되지 않으므로 추가적인 정리는 하지 않겠다. 읽고 넘어갔다.


