자바 가상머신의 두 가지 주요 서비스
- 메모리 관리
- 애플리케이션 코드 실행

## 1. 전통적인 자바 애플리케이션 수명 주기

자바 가상머신 바이너리 실행($JAVA_HOME/bin/java) -> 클래스 이름을 포함한 명령줄 인수 전달 -> 명령줄 플래그 분석 -> 플래그에 따라 가상 머신 초기화 준비(힙 크기, 가비지 컬렉션 설정 등) -> 동시에 실행중인 머신을 조사하여 시스템 정보 수집(CPU 코어 수 등) -> 최적화 진행(공용 스레드 풀 설정 등) -> 새로운 스레드에서 `JNI_CreateJavaM`함수를 사용해 가상 머신이 생성 -> 가비지 컬렉션스레드, JIT 컴파일 스레드 같은 내부 스레드도 함께 시작 -> 부트스트랩 클래스 로드, 첫 번째 바이트 코드 실행, 첫 번째 객체 생성(static {}, 등) -> 안정 상태 돌입 (동시 시작한게 많아서 어느정도 마무리 되는 단계)

이 과정 중 마지막에 핵심 프레임워크 클래스가 먼저 로드되는 등 특수한 경우가 있을 수 있다.
과정이 매우 동적인 런타임중에 진행된다는점을 인지하고 있으면 된다.

## 2. 바이트코드 해석

자바 가상 머신은 빅 엔디언, 리틀 엔디언과 상관없이 동작하게 설계되어있다.
책에서는 자바에서 지정한 바이트코드의 여러 종류에 대해서 설명하고 있다.(load, ldc, add, rem,...)


## 3. 핫스팟에서의 JIT 컴파일

JIT 컴파일은 프로그램을 실행 시점에 기계어로 변환하는 기술

### 프로파일 기반 최적화

프로그램 실행 중 데이터를 수집하고 프로파일로 만드는데, 가장 자주 실행되는 부분을 파악하여, JIT 컴파일을 통해 최적화의 이점을 최대화할 수 있는 부분을 결정하는데 활용된다.

프로파일은 애플리케이션 실행될 때마다 처음부터 다시 생성되어야한다. 재사용을 못하는데 만약 매 번 실행할때마다 비즈니스 로직같은게 다르다면 최적화하는 의미가 없고 오히려 더 느려질 수 있기 때문이다.

### Klass 워드, 가상 함수 테이블, 포인터 스위즐링 수명 주기

핫스팟은 멀티스레드C++기반. 여러 스레드 그룹이 있는데 JIT 컴파일을 담당하는 스레드들도 있다.
JIT 컴파일은 메서드 단위로 작동하며, 가상 함수 테이블이 그 핵심 역할을 담당함.

컴파일이 필요하다는 신호 감지 -> 해당 메서드는 컴파일러 스레드로 보내짐 -> 백그라운드에서 컴파일 -> 최적화된 기계 코드 생성 -> 해당 클래스의 **가상 함수 테이블**이 새로 생성된 코드로 연결되도록 업데이트(이 과정을 **포인트 스위즐링**이라고 함)

핫스팟 자바 가상 머신에는 JIT 컴파일러가 하나가 아니라 2개 들어있다. 각각 C1, C2로 불리고 클라이언트 컴파일러, 서버 컴파일러라고도 불린다. 계층적 컴파일을 진행하는데, 간단한 C1 컴파일된 코드가 준비되면 이를 사용하고, 그동안 C2는 더 고급 최적화를 완료하는 방식으로 동작함. 더 자세한 설명이 있긴하지만 이런 느낌으로 동작한다는 것으로 파악하면 될 듯하다.

### 코드 캐시

- JIT로 컴파일된 코드는 **코드 캐시**라는 메모리 영역에 저장됨.
- 플래그값을 넣어서 최대 크기를 지정할 수 있음. `-XX:ReservedCodeCacheSize=<n>` 코드 캐시가 가득차면 컴파일이 불가능해지고, 컴파일되지 않은 코드는 인터프리터로만 실행됨.

### JIT 컴파일 로깅

`-XX:PrintCompilation`으로 컴파일 이벤트들을 출력할 수 있다.
- 메서드가 컴파일 된 시점, 몇 번재로 컴파일되었는지 숫자값, 기타 필드가 포함되어있다.

`-XX:+LogCompilation`: 세부적인 과정을 더 자세히 확인 가능
`-XX:UnlockDiagnosticVMOptions`: 가상 머신이 바이트코드를 네이티브 코드로 변환하는 과정에서 대기열 처리 또는 최적화 정보를 XML 태그 형식으로 담은 로그파일 생성. 파일이 크다.


### 간단한 JIT 튜닝

- PrintComilaion 플래그를 켜고 애플리케이션을 실행
- 컴파일된 메서드에 대한 로그 수집
- ReservedCodeCacheSize 옵션으로 코드 캐시 크기를 늘림
- 애플리케이션 실행
- 확장된 캐시로 컴파일된 메서드 변화 확인

=> 캐시크기를 늘려도 컴파일된 메서드 수가 증가하지 않는다면 JIT 컴파일러는 리소스 부족 상태가 아닌 것이다. 
=> 컴파일 로그를 확인했을때 컴파일되지 않은 누락된 메서드가 존재한다면 왜 컴파일이 되지 않았는지 추적하는 방향도 있다.

**이 방법들의 핵심은 코드 캐시가 부족하지 않도록 보장하여 JIT 컴파일러가 중단되지 않도록 하는 것이다.**

## 4. 자바 프로그램 실행의 진화

전체적인 수명 주기는

JVM Process -> 앱 로드 -> 준비 과정 -> 안정 상태 -> 셧다운

형태로 돌아간다.

이 주기에서 가장 큰 문제는 애플리케이션이 안정 상태에 도달하기까지 실행 속도가 느릴 수 있다는 점. 장시간 실행되는 애플리케이션에서는 큰 문제가 되지 않음. JIT 컴파일된 코드의 이점이 초기 생성 비용을 훨씬 능가하기 때문. 다만 클라우드 네이티브 환경에서는 프로세스가 훨씬 짧은 시간 동안 실행되는 경우가 많다. 그러기에 실행 속도를 줄이기 위한 여러 고민들을 진행하게 되었는데, 고민들을 해결하기 위해 설계된 현대적이고 인기 있는 프레임워크 중 하나인 **쿼커스**에 대한 논의를 진행될 것임. 그 전에 **AOT 컴파일**에 대한 이해가 필요함.

### AOT컴파일

컴파일러가 사람에게 일기 쉬운 소스를 받아 바로 실행 가능한 기계어 코드로 변환하는 과정.

보통 실행하려는 플랫폼과 프로세스 아키텍처에 맞춘 실행 파일을 생성하려고 하는데, 대부분의 경우 실행 파일은 실행된 플랫폼에 대한 구체적인 정보를 모른 채 생성된다. 고급 JIT 컴파일러는 이러한 제한이 없어서 실행 시 CPU를 검사하여 사용 가능한 명령어를 확인하고 JIT컴파일러를 실제 실행 환경에 맞게 조정한다. 
전통적으로 자바 애플리케이션은 AOT 컴파일되지 않는다. 자바 가상 머신이 **리플렉션**을 사용한 매우 동적인 실행 환경이라는 점 때문이다. 

### 쿼커스

클라우드 네이티브 환경을 위해 설계된 자바 프레임워크. 빠른 시작 속도와 개발자의 생산성을 높이는 데 최적화 되어 있다.

- 자바 애플리케이션 수명 주기에 **빌드**단계를 추가하여 시작 시점에 수행되는 작업의 상당 부분을 미리 처리하여, 계산 작업을 실행 시점에서 컴파일 시점으로 옮김.
- 클래스 패스 어노테이션 스캐닝과 같은 작업을 실행 시점에서 빌드 시점으로 이동시키고 **Jandex**라는 인덱싱 기능을 제공하고 **Gizmo**라는 바이트코드 생성 라이브러리를 통해 리플렉션 사용을 줄이거나 제거한다.
- 두 가지 모드가 존재하는데, 전통적인 방식으로 핫스팟 자바 가상 머신을 사용하는 동적 가상 머신 모드, 그랄 VM 네티이브 이미지 컴파일러가 제공하는 AOT기능을 사용하는 **네이티브 모드**이다.
- 많은 작업들이 빌드 시점으로 이동하여 전통적인 자바 스택으로 실행했을 때의 응답이 4.3초라면 쿼커스 + JITs는 0.9초, 네이티브 컴파일은 0.01초만에 완료된다. (숫자는 참고용)
- 개발 모드를 제공하여 **라이브 리로드**, 백그라운드 컴파일 기능을 제공한다.
  - 자바 파일이나 리소스 파일을 수정하고 브라우저를 새로고침하면, 변경된 내용이 자동으로 적용된다.
- 명령형과 반응형 두 가지 스타일의 애플리케이션 개발을 모두 지원하므로 Spring MVC, Spring WebFlux같은 프로그래밍에서도 적용할 수 있다.


### 그랄VM

자바 또는 기타 자바 가상 머신 언어로 작성된 애플리케이션의 실행 성능을 가속화하기 위해 설계된 고성능 JDK

- 트러플 언어로 작성됨.
- **네이티브 이미지 기능 존재**(사실상 핵심)

## 총평

이러한 내용은 면접에서도 자주 물어보고 알아두면 좋은 내용인 건 확실하다. 좀 깊은 감이 없지 않아 있어서 복습은 필수이다.
어떤 문제가 있었고 이를 해결하기 위해 쿼커스, 그랄VM에 대한 내용을 알려주는건 좋았다.