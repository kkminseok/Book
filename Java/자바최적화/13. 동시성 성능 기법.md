## 사전 개념

- 데이터 병렬성: 하나의 일을 여러 프로세서(코어, 스레드)가 동시에 처리하는 방식
- 작업 병렬성: 서로 다른 작업을 여러 프로세서가 동시에 처리하는 방식

**암달의 법칙**이라는게 있는데, 이는 직렬로 실행해야할 부분(S)과 병렬로 실행해야할 부분(P)이 있고, 이 전체 시간은 T라고 했을 때 프로세서의 수 상관없이 전체 시간(T)는 결국 직렬로 실행해야하 부분(S)보다 작어질 수 없다는 것을 의미한다.
하지만 이러한 법칙으로 알 수 있는건 병렬처리 부분에 한해서 **무한한 성능 향상**이 가능하다는 것이다. 그렇지만 전제가 있다. 병렬처리로 하는 부분끼리 독립적으로 동작해야하고, 공유 상태나 데이터가 없어야한다는 것이다. 

책에서 동시성 예제를 보여주는데, 증감연산에 대한 문제 그런것 세간에 알려진 것을 다루므로 크게 다루지 않겠다.

## 자바 메모리 모델의 이해

자바 메모리 모델은 **약한 메모리 모델**을 채택하고 있다. 약한 메모리 모델이란 CPU 코어마다 서로 다른 값은 볼 수 있고, 한 프로세서가 데이터를 변경하더라도 다른 프로세서가 그 변경을 즉시 못 볼 수도 있고, 메모리 연산 순서가 보는곳마다 다를 수 있는 구조이다. 이렇게 보면 약한 메모리 모델이 별로 안 좋아보이지만, 반대로 모든 프로세서가 동일한 순서로 관찰하는 **강한 메모리 모델**은 성능 오버헤드가 너무 크다는 단점이 있다. 결국에는 분산 환경에서는 성능을 위해 대부분 약한 메모리 모델을 채택하고 있다.

옛날에는 자바에서 메모리 모델은 비동기화 접근에 대해서 어떠한 보장을 알아서 해주지 않기에 `synchronized`키워드를 통해 이를 개발자가 보장하도록 하였다.

- `synchronized`: 2가지 특징을 지니고 있다.
    - 상호배제: 이 키워드가 적용된 블록이나 메서드는 오직 하나의 스레드만이 접근할 수 있다.
    - 메모리 가시성: 블록이 종료하는 스레드는 해당 블록 내에서 발생한 모든 메모리 변경사항을 기록하고, 락을 해제한다. 반대로 블록에 진입하는 스레드는 락을 획득하기 전에 **메인 메모리에서 최신 값을 읽어와**자신의 캐시를 업데이트한다.


## 동시성 라이브러리 구축

책에는 딱히 설명되어 있지 않은데, 동시성 문제를 해결하는 여러 방법?에 대해서 논의하는 챕터 같다.

### 메서드와 변수 핸들

책에 정리된 내용이 내 기준에서는 이해하기 어렵게 설명되어 있어서 AI툴에도 질문해가며 도출된 내용을 정리해야겠다.

`java.lang.invoke` 패키지에는 제공하는 키워드들을 말하는데, 저수준(low-level)에서 동적으로 메서드를 호출하거나 필드에 접근하는 메커니즘이다.
특히 `VarHandle(변수핸들)`은 자바9에서 도입되면서 volatile, CAS같은 메모리 조작 기능을 안전하고 표준화된 방식으로 대체하기 위해 만들어졌다. 동시성측면에서 중요하다.

- MethodHandle(메서드 핸들): 리플렉션의 대안으로, 보다 좋은 성능과 타입 안정성을 제공하는 메서드다. 
- VarHandle(변수 핸들): **원자적 연산과 메모리 순서화제어**에 특화되어 있는 참조이다. 동시성 프로그래밍에 매우 중요한 키워드이다.

## 동시성 라이브러리 요약

위에서는 저수준단계에서 구현기술을 봤고, 이를 이용한 다양한 라이브러리를 살펴보는 챕터같다.

### Java.util.concurrent의 잠금

자바5에서 생긴 `java.util.concurrent.locks.Lock`에서 제공하는 잠금 관련 메서드들.

한 메서드에서 잠금을 설정하고(lock()) 다른 메서드에서 해제하는 것(unlock())이 가능하다. 스레드가 차단없이 획득하려는 경우, tryLock() 메서드를 사용하여 잠금이 가능하면 획득하고, 가능하지 않으면 빠져나올 수 있다.

`ReentrantLock`은 Lock의 주요구현체이며, 가장 큰 특징은 **재진입**에 대한 개념인데 락을 이미 획득한 스레드가 동일한 락을 다시 획득하려고 할 때, 데드락(DeadLock)에 빠지지 않고 성공적으로 락을 재획득할 수 있도록 허용한다. 락의 내부 카운트를 증가시키고, 락을 해제할 떄 카운트를 감소시킨다. 카운트가 0이 되어야 락이 완전히 배제된다. 


### 읽기/쓰기 잠금

ReentrantLock은 단일 잠금 전략인데, 읽기 쓰기에 상관없이 락을 걸면 효율이 떨어질 수 있다. 읽기 작업은 상태를 변경하지 않기 떄문에 굳이 락을 안 걸어도 되기 때문이다. `ReentrantReadWriteLock`은 읽기, 쓰기 락을 분리하여 좀 더 효율적으로 사용할 수 있게 한다. 쓰기락이 걸렸있다면 읽을 때 해당 작업이 완료될 때까지 기다리고, 읽기락에 대해서는 제한을 하지 않는다. 반대로 읽기락이 걸렸으면 쓰기에 대한 작업은 대기 시킨다. 결국 읽기락 끼리만 제한하지 않는다.

세마포어 개념, 동시성 컬렉션 언급 등이 책에 소개되지만 정말 언급수준으로 정리하지는 않겠다.

## 실행기와 작업 추상화

### 비동기 실행 소개

Callable에 대한 소개, ExecutorService에 대한 소개.

- Callable: Runnable과 비슷하지만, 결과와 예외를 던지는 특성이 있음. 하나의 함수를 정의함.
- ExecutorService: 관리되는 스레드 풀에서 작업을 실행하는 메커니즘을 정의하는 인터페이스. 풀 내 스레드를 어떨게 관리할지, 풀을 얼마로 지정할지, 스레드 캐시를 사용할지 등 지정할 수 있다. 비동기로 처리됨. 커스텀이 가능하긴 함.

### 포크/조인과 병렬 스트림

포크/조인이란 병렬프로그래밍에서 사용되는 하나의 디자인 패턴이다.
- 포크: 큰 문제를 작은 하위 문제들로 재귀 분할하고, 각 하위 문제는 병렬적으로 처리한다.
- 조인: 분할된 하위 작업들이 완료되면, 그 결과들이 다시 합쳐져 최종 결합을 생성한다.

이런 특성때문에 **병렬 처리가 쉬운 작업**같은 유형의 작업에 적합하다.

`parallelStream()`같은 **병렬 스트림** 메서드를 통해 데이터들을 처리하고 결과를 다시 결합할 수 있다. 포크/조인보다는 높은 추상화를 지니고 있고 저수준의 스레딩 메커니즘이나 데이터 변경 가능성 등에 대한 고민을 피할 수 있게 한다. `parllelStream()`이 내부적으로는 포크/조인 풀을 사용하고 있어서 포크/조인을 구현할 필요 없이 병렬처리 할 수 있도록 추상화되어있다.

### 액터 기반 기법

액터는 4가지 특성을 가짐.
- 상태: 자신만의 내부 상태를 가짐. 액터 자신만이 상태를 변경할 수 있음.
- 행동: 액터는 메시지를 받으면 그 메세지에 따라 특정 행동을 수행함. 상태를 변경하거나 다른 액터에게 새로운 메시지를 보내거나 등..
- 메시지 수신함: 각 액터는 메시지를 받아들이는 전용 '메시지 수신함'을 가지고 있음. 메시지는 일반적으로 비동기적으로 처리됨.
- 메시지 전송: 액터는 다른 액터에게 메시지를 보낼 수 있음. 일반적으로 단방향 메시지

아파치 페코(Apache Pekko)는 액터 기반 시스템을 개발하는 데 사용되는 프레임워크 중 하나이다. 스칼라로 작성되어, 자바 API도 제공하고 있다.

액터 기반의 장점은 동시성 문제를 해결하는데 효과적이고, 액터가 독립적으로 동작하기에 확장성을 지니고 있다. 또한 한 액터에 문제가 생긴다해서 다른 액터까지 영향을 미치지 않기에 내결함성도 뛰어나다.

## 가상 스레드

자바 21에서 가장 주목받는 새로운 기능 중 하나이다.

[따로 정리한 글이 있어서 책 정리는 하지 않겠다.](https://ms727.tistory.com/56)


## 총평

여기서도 번역이 너무 마음에 안든다. 차단 I/O라길래 뭔가 계속해서 생각했는데, 블락킹 I/O를 의미하는 것 같다. 또, '가상 스레드를 계산 집약적인 작업에 사용하지 마세요.'라는 문구가 있는데, 그냥 CPU 연산을 많이하는 곳에 사용하지 마라. 라고 하면 더 이해가 쉽지 않을까? 싶었다.

이런 부분이 흐름을 읽는데 방해된다. 내용도 사실 겉핥기 수준같아서 따로 키워드 중심으로 다시 학습해야겠다는 생각을 했다.

