이벤트 처리가 연쇄적으로 이루어질 경우 하나가 실패하면 나머지도 실패되어야하는데, 그렇게 하기가 쉽지 않다. 전부 롤백을 해야하는데 각자 데이터베이스를 따로 가지므로 트랜잭션 처리가 어렵다. 그래서 '분산 트랜잭션' 개념이 나오고, 이를 해결하기 위한 해법으로 **Saga 패턴**개념이 나오게 되었다. **보상 트랜잭션**을 이용하여 정합성을 유지하려고 하는데 이에 대한 내용을 다뤄볼 것이다.

- 2PC: 고전적인 해결방법. 모든 모듈들이 비즈니스로직을 처리하고 'ok'와 같은 사인을 보내면 중앙 관리자가 이를 받아 커밋을 진행하게 됨. 이 과정에서 lock을 걸기에 성능상의 문제가 있을 수 있다. SPOF문제도 존재한다.

- Saga: 하나의 큰 트랜잭션을 로컬 트랜잭션으로 쪼개고 실패시 보상 트랜잭션을 실행함. 
    - 크레오그래피: 각 서비스가 이벤트를 발행/구독해서 자율적으로 다음단계를 결정함.
        - 결합도가 매우 낮고, 구조가 단순, SPOF 방지 가능. 비즈니스가 흩어져서 이를 파악하기 어려움.
    - 오케스트레이션: 중앙조정자가 전체 비즈니스 흐름을 관리. 
        - 비즈니스가 한 군데 있어서 이해하기 쉬움. 오케트스레이션에 대한 강한 의존성


다만 Saga의 단점은 그만큼 이베트가 늘어나고, 큐도 많이 필요하다. 즉 설계와 구현의 복잡도가 높아진다는 것. 그건 뭐 CAP에 의해서 어쩔 수 없나 싶기도한다.

보상 트랜잭션 자체가 실패할 수 있기에 이에 맞춰서 정합성은 보장되어야한다. 테스트도 어렵다. 따라서 Saga를 도입할떄는 여러 고민들이 필요하다.

