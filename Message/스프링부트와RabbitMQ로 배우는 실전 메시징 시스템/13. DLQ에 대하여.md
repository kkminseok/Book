앞에서 살펴봤던 리큐잉 시스템은 정말 강력하지만, 리큐잉 즉, 재시도를 아무리해도 처리가 불가능한 구조라면 어떻게 처리해야할까?

JSON자체가 깨져있어서 역직렬화가 불가능하거나, 데이터베이스에 찾고자하는 Id가 없거나 하는 등 또는 NullException이 떨어진다면 재시도해도 의미가 없을 것이다. 이러한 메시지를 계속해서 재시도처리해봤자 무한루프에 빠지기 마련이다.

이런 경우 나중에 재처리하기 위해 DLQ(Dead Letter Queue)에 메시지들을 저장한다.

원래의 작업큐 Exchange, 실패한 메시지를 받을 DLQ와 그것을 위한 DLX(Dead Letter Exchange)가 필요하다.

- `x-dead-letter-exchange`: DLX의 이름을 지정한다.
- `x-dead-letter-rouiting-key`: 선택사항으로, DLX로 메시지를 보낼때 사용할 라우팅 키를 지정한다. 지정하지 않으면 메시지가 원래 가지고 있던 라우팅 키를 사용한다.

어떤 경우에 DLQ에 보내지는가?

1. Consumer가 메시지를 명시적으로 거부(Reject)할 때: Consumer가 `basic.reject`, `basic.nack` 명령을 호출하면서 requeue파라미터를 false로 지정하는 경우.
2. 메시지가 TTL을 초과했을 때
3. 큐의 최대 길이를 초과했을 때: `x-max-length` 또는 `x-max-length-bytes`속성이 설정되어 있어 새로운 메시지가 들어오면서 가장 오래된 메시지가 밀려나는 경우

이점은 무엇인가?

- 시스템 안정성 확보: 무한 재시도 루프를 방지
- 실패 데이터 보존: 실패 원인 디버깅 용이
- 후속처리 용이

근데 이런 작업을 수동으로 처리하는데에는 한계가 있다. 때문에 결국 메시지 재처리 패턴을 사용해야하는데, DLQ Consumer를 둬서 DB에 실패 메시지에 대한 정보를 입력하는 모듈을 만들어서 UI에서 버튼 클릭하면 다시 메시지를 보내는 아키텍처 패턴을 사용한다.

마찬가지로 [예제](https://github.com/kkminseok/My-Spring-Test/tree/main/book/spring-boot-rabbitmq)