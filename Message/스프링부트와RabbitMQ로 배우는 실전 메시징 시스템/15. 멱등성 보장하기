- Consumer가 메시지처리를 하였지만, 브로커에 ACK를 보내기전에 네트워크가 장애가 났다거나
- Producer에서 Publisher Confirms의 타임아웃이 발생하여 메시지 전송에 실패했다고 판단하여 재전송했다거나
- 네트워크 장비의 문제로 TCP 패킷이 중복 전송되었다거나

하는 등의 문제가 있을 경우 기능들은 멱등성을 보장해야한다. 금액과 관련되면 더더욱 이를 보장해야하한다.

이런 경우 멱등성 키(Idempotency Key)를 이용한 중복 처리 방직 로직을 들 수 있다.

개념은 간단하다. 고유한 키를 생성하여 메시지 헤더나 페이로드에 포함시킨다. 작업 처리상태를 기록하는 별도의 저장소에서 Consumer가 실제 비즈니스 로직을 처리하기 전에 이를 조회한다.

만약 멱등성 키가 디비에 존재하지 않는다면 최초 처리이므로 이를 처리한다. 만약 멱등성 키가 존재하면 중복처리된 로직이므로 작업을 건너 뛴다.

저장소는 레디스나 디비를 고를 수 있는데, 둘 다 장단점을 가지고 있다. 레디스는 빠르고, 디비는 느리지만 로직과 멱등성 상태 업데이트를 원자적으로 묶을 수 있다.


마찬가지로 [예제](https://github.com/kkminseok/My-Spring-Test/tree/main/book/rabbitMQ-Spring-Book-Test)