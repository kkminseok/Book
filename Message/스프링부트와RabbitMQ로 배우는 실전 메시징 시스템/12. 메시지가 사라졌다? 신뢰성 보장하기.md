메시지는 어디서 사라질 수가 있는가?

1. Producer -> Broker구간
    - 네트워크 문제, 브로커 문제 등으로 Broker에 메시지가 도달하지 못하는 경우
    - **Publisher Confirms**으로 보강 가능
2. Broker 내부
    - Broker가 Consumer에 메세지를 보내기 전에 재시작되거나 하는 등의 경우
    - **Durability**로 보강 가능
3. broker -> Consumer구간
    - Consumer가 메시지를 처리하는 도중에 비정상 종료되거나 하는 등의 경우
    - **Consumer Acknowledgement**로 보강 가능

## Consumer Acknowledgement

- 브로커는 Consumer로부터 작업 완료 신호를 받기 전까지는 메시지를 큐에서 완전히 삭제하지 않음.
    - Consumer에서 비즈니스 로직 성공시 **ACK**신호를 보냄. 실패시 실패한 메시지를 다시 큐로 되돌려놓음.
        - 스프링 기준 세가지 옵션 존재
        - NONE: 메시지를 보내는 즉시 메시지를 큐에서 삭제(비권장)
        - AUTO(기본값): 메서드의 실행을 보고 자동으로 ACK/NACK보냄. 
            - 주의해야할 것은 `try-catch`로 예외를 잡아버리면 NACK를 보내지 않고 성공(ACK)로 간주함. `AmqpRejectAndDontRequeueException`로 리큐잉 안하게할 수 있음.
        - MANUAL: 명시적으로 개발자가 ACK/NACK를 보냄. 완벽한 제어. 복잡한 코드

## Publisher Confirms

- 브로커가 Producer에게 메시지를 잘 받았음 여부를 알려주는 기능
    - 브로커 내부 문제(존재하지 않는 Exchange로 라우팅 시도, 디스크 공간 부족 등)로 메시지를 처리할 수 없으면 **NACK**를 보냄.
    - Producer는 ACK/NACK 응답을 비동기적으로 수신하기 위한 **콜백**을 등록해둠. 
        - 스프링 기준 세가지 옵션 존재
        - NONE(기본값)): 기능 비활성화
        - SIMPLE: 동기 방식(거의 안 쓰임)
        - CORRELATED: 비동기 방식(권장)
        - `spring.rabbitmq.publisher-returns`이 옵션을 통해 콜백을 등록할 수 있음.
        

