레디스 클러스터의 개요와 장점, 동작 원리, 핵심기능중 하나인 장애 탐지 기능에 대해 알아보도록 한다.

## 레디스 클러스터 개요

- 여러 캐시 노드를 연결하여, 일부 장애가 발생해도 시스템을 계속 운영할 수 있도록 **페일오버** 기능을 지원한다. 
- 샤딩을 통해 노드 사이에 키를 옮길 수도 있음.
- 페일오버와 샤딩을 통해 높은 가용성을 보장하며, 쓰기 및 읽기 작업의 확장성도 높일 수 있다.
- 레디스 클러스터는 클라이언트 요청에 대해 클러스터 내 각 노드로 요청을 분배하는 과정에서 프록시를 사용하지 않으므로 프록시로 인한 오버헤드가 없다.
- 만약 데이터를 갖고 있지 않은 노드에 요청이 들어올 경우, 레디스 클러스터는 클라이언트에게 데이터를 가진 마스터 노드의 정보를 제공하고, 해당 노드로 요청을 리다이렉트한다. 이 과정에서 얻은 정보를 클라이언트가 저장하고 있다면, 다음 요청부터는 리다이렉트에 의한 오버헤드도 없앨 수 있다.
- 레디스 클러스터는 총 16,384개의 해시 슬롯이 있다.

### 레디스 클러스터가 사용하는 두 개의 TCP 포트

레디스 클러스터를 연결하기 위해서는 두 개의 TCP 포트를 사용한다. 
- 첫 번째 포트는 클라이언트로부터 TCP 연결을 받는 포트로, 6379번이 그 포트이다.
- 두 번째 포트는 클러스터 내부 통신을 위한 포트로 기본값에 +10,000을 더한 값(기본세팅의 경우 6379+10000)을 사용한다. 이를 **클러스터 버스 포트**라고 한다.
  - 통신 방식은 **가십 프로토콜**을 통해 이뤄지는데, 이 프로토콜은 클러스터의 노드 수가 증가해도, 노드 간 메시지 수가 지수적으로 증가하지 않도록 고안되었다.
  - 내부적으로는 클러스터 내의 노드 간에 설정 정보를 서로 공유하고 인지하기 위해 **Raft**라는 분산합의 알고리즘을 기반으로 시스템이 구현되어 있다.
  
### 동작 메커니즘

레디스 클러스터에서 클라이언트 요청 처리는 다음과 같은 흐름으로 진행된다.

1. 클라이언트가 클러스터를 구성하는 캐시 노드 중 하나의 IP주소에 접속
2. 접근 노드의 레플리카 마스터인 경우 다음과 같은 내용에 따라 조건 분기를 진행
   1. 접근 노드가 레플리카인 경우 
      1. 읽기 쿼리: READONLY 명령어 실행 여부에 따라 동작한다.
         1. READONLY 명령어가 실행되었고, 해당 키가 노드의 슬롯범위 내에 있는 경우 요청된 캐시노드에서 요청을 처리한다.
         2. 그 외의 경우에는 레디스 서버가 MOVED 리다이렉트를 클라이언트에 응답 -> 클라이언트가 MOVED 리다이렉트를 받고 로컬 슬롯 매핑을 업데이트 -> 클라이언트가 해당 키의 슬롯을 가진 샤드의 마스터에 접근
      2. 쓰기 쿼리: 레디스 서버가 MOVED 리다이렉트를 클라이언트에 응답 -> 클라이언트가 MOVED 리다이레그를 받고 로컬 슬롯 매핑을 업데이트 -> 클라이언트가 해당 키의 슬롯을 가진 샤드의 마스터에 접근
   2. 접속 노드가 마스터인 경우
      1. 키가 해당 캐시노의 슬롯 범위인 경우에는 요청된 마스터에서 처리
      2. 슬롯 범위 밖인 경우에는 레디스 서버가 MOVED 리다이렉트를 클라이언트에 응답 -> 클라이언트가 MOVED 리다이렉트를 받고 로컬 슬롯 매핑을 업데이트 -> 클라이언트가 해당 키의 슬롯을 가진 샤드의 마스터에 접근

즉 전체적인 동작방식은 레플리카로 접근했을 경우 데이터가 존재하지 않으면 해당 레플리카가 마스터 노드의 정보를 리다이렉트하고 마스터로 접근하게끔하여 처리하게 하는 것이다.



## 클러스터 장애 탐지

- 각 캐시 노드의 상태는 PFAIL, FAIL 두 가지로 나뉠 수 있다.
   - PFAIL: Possible Failure의 약자
      - 특정 노드가 다른 노드에 핑을 보내고, cluster-node-timeout 이내에 응답이 오지 않을 때, 핑 대상 노드를 PFAIL로 둠
      - cluster-node-timeout/2 만큼 시간이 지나도 핑의 응답이 오지 않으면 연결 재시도
      - 마스터 노드가 PFAIL상태이면 페일오버를 실행할 수 없다.
   - FAIL
      - FAIL상태가 되어야 마스터의 페일오버를 실행할 수 있다.
      - 과반수의 마스터 노드가 대상 노드를 PFAIL, FAIL 상태로 판단하는 경우, 해당 노드는 FAIL

- 마스터가 정상적으로 동작하지 않으면 레플리카는 자동으로 새로운 마스터로 페일오버를 실행
   - 다음 조건들을 만족하는 레플리카가 마스터 후보가 되며 선출 프로세스가 시작된다.
      1. 레플리카 마스터가 FAIL 상태여야한다.
      2. 마스터가 하나 이상인 슬롯을 관리한다.
      3. 레플리카가 일정 시간 이상 마스터와의 연결이 끊긴 상태여야 한다.
   - 선출 프로세스
      1. 마스터가 FAIL인 레플리카는 일정시간 대기 후, 클러스터 내 각 마스터에게 인증요청 패킷을 브로드 캐스트함.
      2. 각 마스터는 해당 패킷을 받으면 응답함.
      3. 레플리카는 currentEpoch 이하의 에포크 응답을 무시하고, 그렇지 않은 경우에는 반영함(오래된건 무시한단 뜻임)
      4. 과반수의 마스터로부터 투표를 받으면, 해당 레플리카가 승격됨. 과반수로 도달하지 못하면 특정 시간만큼 대기한 후, 재투표를 진행한다. 


## 용어

- 슬롯: 클러스터는 각 사드는 하나의 마스터와 0개 이상의 레플리카를 가지며, 총 16_384개의 슬롯이 각 샤드에 분배됨. `CRC16(key) % 16384`로 나온 값의 슬롯으로 접근함. 즉, 샤드의 데이터 분산은 키를 해싱한 결과를 슬롯에 할당함.

- 해시태그: 일반적인 경우 레디스 클러스터에서 여러 키를 동시에 조작하는 명령에 대해서는 모든 키가 동일한 슬롯에 있어야하고, 그렇지 않은 경우 오류를 내뿜는다. **해시태그**를 사용하면 키다 달라도 같은 슬롯에 접근할 수 있게함.

   예:
	•	user:{1001}:profile
	•	user:{1001}:cart

- 클러스터 버스: 클러스터 내의 각 노드는 클러스터 버스라고 하는 TCP 버스를 통해 이진 프로토콜과 완전 메시 구조로 서로 연결되어 있다. MEET메시지, 가십 프로토콜을 통해서 노드가 추가되더라도 모든 노드가 이를 인식할 수 있다. 

- 파티셔닝: 여러 레디스 인스턴스 간에 데이터 셋을 분할하여 저장하는 작업. 이를 활용하면 여러 컴퓨터의 메모리의 총 용량을 활용하여 큰 데이터베이스를 사용, 컴퓨터 처리능력 향상, 네트워크 대역폭 확장이 가능하다.
   - 키를 분리하는 방식에 따라 레인지 파티셔닝, 해시 파티셔닝로 나뉨.
   - 파티셔닝 실행방식
      - 클라이언트 측 파티셔닝: 어느 노드로 요청을 보낼지 클라이언트에서 결정하는 방식
      - 프록시 기반 파티셔닝: 위와 동일하지만 프록시가 요청을 받아 대상 노드로 라우팅
      - 쿼리 라우팅: 요청을 무작위 노드로 보내고, 그 노드가 요청 처리에 적합하지 않으면 다른 노드로 리다이렉트함. 
      - **레디스 클러스터는 클라이언트 측 파티셔닝 + 쿼리 라우팅을 결합한 형태. 레디스 클러스터 프록시는 프록시기반**

## 레디스 클러스터 구성

- `redis-cli -cluster create` 명령어는 구축, 준비 ,확인 등 모든 작업을 한 번에 처리함.
- `INFO Replication`으로 레플리카 정보를 확인할 수 있다.
- Redis 7.0부터는 `CLUSTER SHARDS` 명령어 사용할 수 있다. 각 샤드의 슬롯 범위 및 캐시 노드의 세부 사항을 확인할 수 있다.
- `--cluster-only-masters`, `--cluster-only-replicas` 옵션을 사용하여 모든 레플리카 또는 마스터에 명령어를 사용할 수 있다.

- 외에 책에는 레플리카 추가하는법 등이 나와있는데 크게 어렵지 않으므로 넘어가겠다.

## 전체 평

개요부터 동작방식까지 깔끔하게 알려준 것 같다. 이해하는데도 크게 어렵지 않았다. 실제 실행환경도 보여줘서 이해하는데 도움이 되었다. 다만 하나의 걱정은 클러스터가 이렇게 간단하게(?) 이해하게 되어서 진짜 별 거 아닌 내용인지 아니면 내용이 부실한건지 좀 헷갈렸다.

아무튼 내용 자체는 만족했다.