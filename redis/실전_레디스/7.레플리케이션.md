데이터 레플리케이션은 쓰기 작업이 있을 때마다 업데이트된 데이터를 다른 서버로 계속 보내 복제하는 것을 의마한다.

- 레디스의 레플리케이션은 이벤트 루프의 비동기 논블로킹 방식으로 구현되었다.
  - 따라서 해당 작업이 지연되는 경우가 있으면 마스터와 레플리카 내의 데이터가 동일하다고 보장할 수 없다.
- 기본적으로 레플리카에 쓰기 작업이 불가능하도록 설정되어 있음.
  - `replica-read-only` 지시자를 통해 변경할 수 있지만 요구사항에 맞춰 진행하도록 하자.
- 마이그레이션할 때 레플리카를 활용하여 진행할 수도 있다.

## 시작 메커니즘

1. 레플리카는 `PSYNC`명령어로 마스터에 연결 요청, 해당 시점까지 처리한 레플리케이션 ID와 오프셋을 전송
2. 마스터는 요청받은 마스터의 레플리케이션 ID와 자신의 레플리케이션ID가 일치하는지 확인하고, 오프셋이 레플리케이션 백로그의 버퍼에 있는지 확인
3. 두 가지 경우에 따라 처리가 달라짐.
   1. 백로그에서 동기화가 가능한 경우: 부분 동기화 실행
   2. 백로그에서 동기화가 불가능한 경우: 전체 동기화 실행

전체 동기화는 요청 처리에 미치는 영향이 크다. 프로세스가 포크 처리되어 마스터의 메모리 데이터를 덤프하고 디스크에 RDB 파일을 저장하므로 영향이 클 수 밖에 없다.

### 전체 동기화 메커니즘

1. 레플리카가 마스터에 레플리케이션 시작 요청
2. 마스터는 `BGSAVE` 명령어를 실행하여 프로세스를 포크 처리하고, 포크된 프로세스에서 메모리 스냅숏(RDB 파일 생성)을 진행
3. `BGSAVE`처리가 완료된 후, RDB 파일을 레플리카로 전송. 그동안 마스터의 쓰기 작업은 레플리카의 클라이언트 출력 버퍼에 기록. 레플리카는 전송된 RDB파일을 메모리로 불러들임.
4. RDB 파일 전송이 완료된 후, 레플리카의 클라이언트 출력 버퍼에 기록된 데이터를 레플리카로 전송
5. 레플리카의 클라이언트 출력 버퍼에 쓰기 작업이 완료되면, 마스터의 쓰기 작업은 실시간으로 레플리카로 계속 전송됨.

- **TTL이 설정된 키의 레플리케이션 동작방식**은 좀 특이하다.
  - 레플리카에서는 TTL이 설정된 키를 자체적으로 만료시키지 않느다. 만료된 키의 정보는 마스터에서 모든 레플리카로 `DEL` 명령어를 통해 전송된다.
  - RDB 파일을 덤프할 때 만료된 키는 포함되지 않기에 RDB 파일을 읽을 때 마스터에 존재했던 만료된 키는 복원되지 않는다.
    - 이런 동작 때문에 TTL이 설정된 키를 포함할 경우, 마스터에 저장된 키의 개수가 레플리카에 저장된 키의 개수보다 많아 보일 수 있다.
    - 

- 디스크 없는 레플리케이션이라고 RDB파일에 쓰기 작업을 하지 않는 레플리케이션이 있다. 
  - 디스크 속도가 느리면 부하가 클 수 있기에 이런한 방식이 고안됨.
  - 큰 데이터 셋을 처리하거나 디스크 속도가 느리고 네트워크 대역폭이 넓은 경우에 유용함.

- TCP_NODELAY 설정을 활성화하면 레플리케이션의 지연 시간은 감소하지만, 사용하는 대역폭이 증가한다. 이 기능을 비활성화하면 더 적은 TCP 패킷으로 레플리카에 데이터를 전송하므로 지연 시간이 증가할 수 있다. 
  - 높은 트래픽이나 마스터/레플리카 간의 거리가 먼 경우, 이 기능을 비활성화하면 효과적일 수 있다.
  

### 부분 동기화 메커니즘

마스터에는 레플리케이션 백로그라는 불리는 고정 길이의 리스트 위에 있는 메모리 영역이 존재. 레플리케이션 연결이 끊어진 동안에는 이 백로그에 쓰기 작업 정보를 일정시간 동안 관리한다.

따라서 레플리케이션 연결이 끊어진 동안의 모든 쓰기 작업이 레플리케이션 백로그에서 레플리카로 전송됨.

`repl-backlog-size` 지사자로 백로그의 크기를 지정할 수 있다.
만약 지정한 크기를 초과하면 다음 레플리카 연결때는 전체 동기화를 수행한다.

### 동기식 레플리케이션 강제하기

- 비동기 레플리케이션은 데이터 유실이 존재할 수 있기에 **동기식 레플리케이션**을 강제할 수 있다.

- `WAIT` 명령어를 사용하면 된다.
  - 해당 명령어는 클라이언트가 지정한 개수만큼의 레플리카로부터 응답을 받을 때까지 다른 클라이언트를 차단하도록 동작한다.

## 레플리케이션 동작 중 메커니즘

- 마스터는 기본적으로 10초 간격으로 모든 레플리카에 ping을 보낸다.
  - `repl-ping-replica-period` 지시자로 조정이 가능하다.
- 레플리카는 매초 REPLCONF ACK <offset> 명령어를 사용하여 처리한 위치를 포함해 핑을 보내고, 마스터는 각 레플리카로부터 받은 마지막 핑의 시간을 기록한다.
  - 이 매커니즘을 통해 마스터는 일정 시간내로 핑을 받지 못하면 연결이 끊어진 상태로 인식함. `min-replicas-max-log` 지시자로 해당 값을 조정할 수 있고 기본값은 10초이다.
- 마스터에 값을 저장하기 위해 최소한으로 필요한 연결 상태의 레플리카 개수도 `min-repkicas-to-write` 지사자로 설정이 가능하다.
  - 이 값릍 통해서 데이터 손실에 대한 문제가 발생하였을때 마스터로 쓰기 작업 대신 오류 메시지를 반환하도록 할 수 있다.
- 마스터와 레플리카 사이의 핑은 타임아웃이 존재한다. `repl-timeout` 지사자로 조절할 수 있다. 기본값은 60초
  - 위에서 설명한 `repl-ping-replica-period`는 `repl-timeout`보다 적게 설정해야하는데 그렇게 하지 않으면 타임아웃이 나서 레플리케이션 연결이 끊어질 것이다.
  

  ## 페일오버

  레디스는 기본적으로 마스터에 문제가 발생했을 때 자동으로 페일오버하는 기능이 없다.(레디스 클러스터나 센티널을 사용하면 자동 페일오버 기능을 사용할 수 있다.)

  마스터가 다운 되었을 경우, 새로운 마스터로 승격시킬 노드에서 `REPLICAOF NO ONE` 명령어를 수동으로 실행해야함. 



  ## 전체 총평

  - 레플리카에 대한 상세한 설명이 좋았다. 확실히 첫 부분을 지나고나니 좀 더 유용한 내용들이 많다고 느꼈고 따라가는게 마냥 막 벅차지 않아서 레디스 별거 없는데? 라는 생각이 들었다. 물론 저수준에서 여러기능을 제공하는 것을 보고 방대하고 대단하다고 느꼈다. 레디스가 아무래도 하드웨어와 밀접해서 그런지 기능 자체는 직관적이고 단순하다고 느껴서 레디스에 대한 두려움이 좀 사라졌다.

