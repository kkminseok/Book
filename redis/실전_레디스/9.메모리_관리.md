레디스는 `malloc` 함수를 통해서 메모리를 할당하기 때문에 운영체제의 메모리 페이지 할당 매핑을 제어할 수 없도록 구현되었다.
    - 레디스에서 데이터 삭제 명령을 실행해도 확보된 메모리가 운영체제로 반환된다는 보장이 없다. 즉, 삭제해도 운영체제는 삭제한 데이터의 크기만큼 메모리를 줄이지 않을 수 있기에 주의해야한다.

- 레디스 클라이언트에서 보낸 명령어는 '클라이언트 쿼리 버퍼'에 저장 후 소켓으로 보냄. 
- 반대로 명령어의 실행 결과는 '클라이언트 출력 버퍼'라는 클라이언트별 버퍼에 저장. 소켓을 통해 데이터를 원자적으로 처리함.


## INFO Memory 해석

중요해보이는 것만 정리

- used_memory: 할당한 메모리 크기
    - 데이터 뿐만 아니라 클라이언트 출력 버퍼 등도 포함
- maxmemory: 레디스가 사용할 수 있는 최대 메모리 크기(설정 가능)
- mem_not_counted_for_evict: AOF 버퍼, AOF 재작성 버퍼, 스냅숏 생성할 때 CoW에 의해 사용된 메모리 양
    - 이 값은 user_memory에서 포함되지 않음.
- maxmemroy-clients: 모든 클라이언트가 사용하는 메모리 소비량 제한 가능
- used_memory_overhead: 오버헤드를 관리하는 데 사용되는 내부 데이터 구조
- used_memory_dataset: 데이터 셋의 메모리 크기
- used_memory_dataset_perc: 데이터셋이 차지하는 전체 메모리의 비율
- mem_fragmentation_ratio: 메모리 단편화 비율
    - 1.0이거나 그보다 약간 높으면 양호
    - 1.5 이상이거나 1.0 미만이면 단편화가 심각 or 스왑이 발생하고 있을 가능성 존재
    - 단편화 발생시 재시작, 동적 단편화, 메모리 스왑 제한, 메모리 할당자, `MEMORY PURGE` 명령어 실행 등으로 대처할 수 있다.

## 클라이언트 출력 버퍼

- 레디스 서버는 각 클라이언트, 레플리카, Pub/Sub 기능용 **COB(Client Output Buffer)**를 가지고 있음.
    - 서버에서 처리한 결과를 클라이언트에 직접 보내지 않고 COB에 저장하고 한 번에 전송됨.

### 종류

- pub/sub기능의 경우 모종의 이유로 클라이언트가 메시지를 소비하지 못한 경우 이는 레디스 서버 메모리에 쌓여 용량이 증가하게 된다. 이때 COB의 pubsub 유형은 버퍼 크기에 제한을 두어, 일정 버퍼가 초과되면 연결을 끊는다.
- replica유형은 레플리케이션 과정 중에 처리된 마스터의 쓰기 작업을 레플리카에도 반영하기 위해 사용된다. 이때 쓰이는 COB의 크기가 너무 작으면 레플리케이션이 제대로 이루어지지 않을 수 있다. 따라서 적절하게 설정하거나 아예 비활성화하는 것도 방법이다.
- normal유형은 일반적은 버퍼유형이다. 클라이언트가 하나의 명령을 보낸 후, 다음 명령을 보내기 전에 응답을 올때까지 기다리는 버퍼이다.
    - 보통 COB에 대한 제한값은 0이다. 연결을 끊는 경우가 바람직하지 않은 경우가 많기 때문이다.

- `client-output-buffer-limit` 지시자는 레디스에서 클라이언트 출력 버퍼 크기를 제한 설정함.
    - 세 가지 유형에 대해 모두 하드 리미트와 소프트 리미트 설정이 가능하다.
    - 하드리미트: COB의 메모리 크기가 설정된 리미트에 도달하면 바로 연결이 끊김.
    - 소프트리미트: COB의 메모리 크기가 설정된 리미트에 도달하고 일정시간동안 지속되면 연결이 끊김.
- redis 7.0 이상에서는 메모리 조정하는 알고리즘이 변경됨.(기존보다 좀 더 동적으로)

## 키 만료

레디스에서 키를 삭제한다고해서 메모리에서 사라지는건 아니다.
두 가지 방법으로 이 데이터를 삭제할 수 있다.

- 수동적 방법: 클라이언트가 키에 접근할 때 해당 키의 TTL이 만료되었는지 확인 후, 만료되었다면 해당 키를 메모리에서 삭제
- 능동적 방법: 레디스가 매 초마다 10번, 임의로 20개의 키를 샘플링하여 만료된 키를 확인하고 삭제함. 만약 샘플링된 키 중 25%이상 만료되었으면 한 번 더 삭제과정을 진행함. 
    - 싱글 스레드로 처리하기에 지연 시간이 존재할 수 있음.

### 삭제 정책

만료될 키가 없다면 메모리가 증가할 것이고, 만료되지 않는다해서 계속해서 둘 수는 없다. 삭제 정책이 필요하다.

- maxmemory 지시자로 설정된 값에 도달했을 때, maxmemory-policy에 설정된 정책으로 키를 삭제하도록 한다.
    - noeviction: 오류를 반환하고 어떤 키도 삭제하지 않는다.
    - volatile-random: TTL이 설정된 키 중에서 임의로 키를 선택해 삭제한다.
    ...LFU, LRU삭제 등이 존재한다.

## 메모리 관리 기타 방법

- 동적 리해싱
    - 레디스는 하나의 큰 해시 테이블을 사용하여 데이터 관리를 함. 동적 리해싱 방식은 리 해시 테이블의 크기를 사용하려는 상황에 맞추어 자동 조정함.
    - 새 테이블을 추가로 준비하여, 작업이 수행될때마다 새로운 아이템이 이 테이블에 저장됨. 또한 오래된 테이블 정보도 저장되고 저장이 완료되면 이전 테이블은 삭제되는 메커니즘
- 동적 단편화 제거
    - 위에서 설명한 `MEMORY PURGE`를 사용할 수도 있지만 `jemalloc`의 기능을 사용하면 좀 더 나은 성능을 보일 수 있다. 레디스 표준은 `jemalloc`이 사용되고 단편화를 줄이도록 내부 설계가 되어있어서 사용하는 것을 권장한다고 한다.




