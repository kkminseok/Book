## 3. 고급 기능

높은 성능을 내기 위한 여러 고급기능에 대한 설명

### 3.1 파이프라인

- 이전 요청 응답을 기다리지 않고 새로운 요청을 보낼 수 있는 기능. RTT를 절약할 수 있다.
- 파이프라인을 사용하면 명령의 순서가 보장되고 오버헤드를 줄일 수 있음.
- 그냥 말그대로 리눅스 파이프라인 적용해보라는거다. 

### 3.2 루아

- 레디스 내장 스크립트 언어
- 레디스 7.0 이후에는 레디스 함수를 사용하지만 그 이전에는 레디스나 **이페머럴 스크립트**로 루아를 실행

이페머럴 스크립트
- 하나의 언어는 아니고 그냥 일시적으로 실행되는 스크립트를 의미함.
- 책에서는 ruby를 통해서 루아 코드를 호출하는데 이를 적지는 않겠음.
- `EVAL` 명령어를 통해서 redis-cli에서 이페머럴 스크립트 실행이 가능.
    - example) `EVAL "local val=0; for i=1, ARGV[1] do val = val +i; end; return val" 0 10`
    - `EVAL`
        - 첫 번째 인수: 스크립트 내용
        - 두 번째 인수: 스크립트 내 사용하는 키 종류의 수
        - 세 번째 인수: 두 번째 인수에서 지정한 수만큼 스크립트 내에서 사용하는 키
    - `EVALSHA`
        - EVAL과 비교하여 첫 번째 인수만 다른데, 스크립트 자체가 아닌 스크립트 해시값을 지정함. 이 해시값은 `SCRIPT LOAD` 명령어로 확인이 가능
        - EVAL과 달리 해시값을 사용하기에 대역폭을 줄이 수는 있음. 주로 현업에서 사용됨.
- 레디스 서버는 실행한 루아 스크립트를 캐시 내부 처리를 통해 비용을 줄이고 있음.
- 만약 스크립트 캐시 내부를 삭제하고 싶다면 `SCRIPT FLUSH` 명령어로 처리가 가능하다.
- 스크립트 존재 여부는 `SCRIPT EXISTS`를 통해 알 수 있다.
- 실행중인 스크립트를 정지하려면 `SCRIPT KILL`, `SCRIPT SHUTDOWN`, `SCRIPT NOSAVE`가 있다.
    - 실행중일때는 Kill, NoSave 명령어가 동작한다.
    - NoSave가 동작하면 모든 클라이언트에서 연결을 끊고, AOF가 활성화된 경우 AOF 플러시 처리를 수행한 후에 레디스 서버를 종료한다.
    - save 지시자로 스냅숏을 기록하도록 설정되어 있어도 생략(no save)함.
    - 타임아웃도 설정이 가능하다.
- 레디스 7.0 이후에는 EVAL_RO/EVALSH_RO가 추가됨. 이름을 봐서 알겠지만 읽기전용 명령어. 이를 통해서 읽기전용 스크립트라면 SCRIPT KILL 명령어 실행을 보장할 수 있어서 의도적인 쓰기 작업으로 발생하는 문제를 줄일 수 있음.
- 옵션을 통해서 루아 디버깅도 가능하므로 참고


**레디스 함수**

- 레디스에서 루아를 실행하는 또 하나의 방법
- 레디스 7.0의 대표적인 기능
- 기존 이페머럴 스크립트의 문제점을 극복하기 위한 대체 기능
    - 스크립트 관리가 어려움. 
    - 스크립트 간 공유와 재사용이 어렵다
- **원자적 처리**가 보장.
- 실행동안은 블락됨.
- 라이브러리 개념을 도입하여 코드 재사용이 쉬워짐.
- `FUNCTION` 명령어로 라이브러리 등록가능
- `FCALL` 명령어로 함수실행 가능
- `FUNCTION FLUSH`로 모든 라이브러리 삭제 가능
- `DUMP`, `RESOTRE` 명령어로 함수 이전도 가능하다.
- redis.call() vs redis.pcall()
    - call()은 오류가 발생하면 그 뒤 명령어들은 실행하지 않음.
    - pcall()은 오류가 발생해도 뒤 명령어는 그대로 처리함. 오류문이 다른곳에서 생성되었기 때문


### 트랜잭션

- MULTI/EXEC 명령어를 통해 다른 클라이언트의 간섭없이 원자적 처리가 가능하다. 
    - (여기서 말하는 원자적 처리가 RDBMS에서의 개념과는 다른듯함)
- 명령어 실행도중 문제가 발생하면 RDBMS처럼 롤백하지는 않고 그대로 남은 작업을 진행함. 
    - 위의 명령어를 통해 실행하는 경우 다른 클라이언트가 간섭할 수 없으므로 격리성은 보장됨. 


## 레디스 모듈

모듈에 대한 개념이 나오는데, 간단히 말하자면 redis서버에서 모듈을 임포트하여 사용할 수 있게 한 방법

## 키공간알림

레디스에 이벤트를 등록하여 특정 동작에 대한 알림을 수신받을 수 있는 기능
- pub/sub 기능을 사용해야함.
- 이 기능은 좀 잘쓰면 유용할 것 같다.
- RESP3에서 사용하면 상관없지만 Redis 6.0이전에 사용하던 RESP2에서는 구현방식의 차이가 좀 존재한다. (우리는 모두 Redis 6.0 이상쓸거죠?)


## 클라이언트 측 캐싱

개념 자체는 레디스에 커넥션 맺는것 자체로도 RTT시간이 증대되므로 레디스 클라이언트 로컬 캐시를 사용하여 값을 저장하는 것을 말함. 

Redis7부터는 이를 도와주는 기능이 생겼음.
Redis는 특정 키의 변경을 감지하여 클라이언트에 무효화 알림(invalid message)를 보냄.
클라이언트는 이 알림을 받으면 자체 캐시를 비우고 다시 redis에서 조회함.






### 후기


|비교항목|MSET|파이프라인|트랜잭션|이페머럴 스크립트|레디스 함수| 모듈|
|-----|----|----|----|----|----|----|
|RTT감소|o|o|o|o|o|o|
|다른 자료형 키를 동시에 다루기|x|o|o|o|o|o|
|원자적 처리|o|x|o|o|o|o|
|복잡한 로직 설계|x|x|x|o|o|o
|처리 도중 계산 결과 사용가능|x|x|x|o|o|o|
|서버 내 스크립트 내구성|x|x|x|..|o|o
|사용자 정의 구조나 명령어 사용|x|x|x|x|x|o|
|서드 파티 라이브러리 사용|x|x|x|x|x|o|


- 운영법에 대해서 학습하고 싶었지만 여기서는 고급기능에 대해서 다루고 있었다. 조금 아쉬웠다. 사실 레디스 함수, 이페머럴 스크립트 등의 개념들은 알아두면 좋겠지만 실무에서 어떻게 쓰일지 감도 잘 안잡혔다. 레디스 함수의 경우는 7.0 버전 이상에서 등장한 것이라 실무에서 바로 쓰이긴 어렵겠다고는 생각했지만 사실 레디스를 간단히 운영하는 상태에서 레디스 함수를 적용해볼까? 라고 할만한데를 못찾고 있다. 단순 캐시기능만 사용해서 그런거일 수도 있다.

그래도 뒤에서는 레디스 운영법에 대한 내용이 나오므로 갈증이 좀 해소되지 않을까한다.
그래도 레디스 함수를 통해서 좀 더 복잡한 로직을 수행할 수 있다? 정도는 이해된 것 같다.

모듈에 대해서는 조금 난해한 부분이 있었다. 이번 챕터의 가장 아쉬운점은 심플하더라도 좀 더 어떤 상황에, 어떤 문제를 해결하고자 이런 개념이 나왔는지에 대한 설명이 부족하다보니 이해하기 어려운 부분이 많았다는 것이다.  사용자 정의 자료구조를 사용할 수 있다는데 이런 상황이 필요한 경우가 언제있는가? 사용자 정의 자료구조란 무엇인가



