레디스 구조를 자체적으로 분석하기 위한 지식, 다소 어려운 내용들을 포함하고 있음.

## 레디스 관련 기술, 용어

- RESP
- SDS
- ae
- RAX
- Copy On Write
- Raft
- HyperLoglog

### RESP

- 레디스를 위해 설계된 프로토콜
- 클라이언트-서버 구조
- 쉬운 구현, 빠른 파싱 속도, 가독성 3가지를 목표로 설계됨.
- 다섯 가지 데이터 유형을 가짐
  - 간단한 문자열(+)
  - 오류(-)
  - 정수(:)
  - 대량 문자열($)
  - 배열(*)
    - 이를 기준으로 데이터를 변경하여 명령어를 레디스에 보냄
    - 예시) set foo bar -> `*3\r\n$3\r\nset\r\n$3\r\nfoo\r\n$3\r\nbar\r\n`로 RESP형식으로 변경되어 레디스에 전달되어 해석됨.

RESP3버전도 현재 나와있음.
- Redis 6.0이상
- 기존 RESP2버전의 표현력을 늘리고 동작 개선과 같은 여러 개선이 있었음.

### SDS(Simple Dynamic Strings)

가변 길이 문자열에 관한 C 언어 라이브러리. 현재는 포크되어 독립된 프로젝트로 공개됨.
- 간단한 사용, 이진 안전, 좋은 계산 효율성, 일반적인 C 문자열과의 호환(미해결)을 목적으로 만들어짐.
- 현재 문자열 길이, 사용 가능한 공간, 실제 문자열이 정의되어 사용됨.
```c
struct sdshdr{
    unsinged int len; // 현재 문자열 길이
    unsinged int free; // 사용 가능한 공간
    char buf[]; // 실제 문자열
}
```
- 문자열 끝에 추가공간이 필요하다면 미리 여유 공간을 만들어 두도록 동작함.
  - 필요 메모리양이 SDS_MAX_PREALLOC보다 적으면 요청 메모리의 두 배를 확보하고, 크면 요청된 크기 + SDS_MAX_PREALLOC마늠 확보함.
- SDS 버전2가 레디스 3.2이후 나왔으며, 메모리 최적화 기능이 향상됨.

### ae

이벤트 기반 라이브러리. 레디스의 싱글 스레드를 통한 요청의 이벤트 기반 처리 기능을 구현한 것.
- epoll, kqueue, select, 등의 래퍼를 사용(운영체제 마다 다름)
- 레디스에서 클라이언트로부터의 요청 처리를 하는 **파일 이벤트**와 정기적인 처리를 담당하는 **타이머 이벤트**를 처리함.
- 안티레즈가 직접 구현한 라이브러리로, 생산성 및 유지보수를 위해 외부 의존성을 줄이고자 했다고함.

### RAX

메모리 관리용 데이터 구조. 안티레즈가 레디스의 성능 문제를 해결하기 위해 만든 기수 트리(Radix Tree)

### CoW(Copy on Write)

레플리카를 생성할 때 바로 복사하는 것이 아닌, 파일에 변경이 있을 때까지 참조본을 생성하는 방식.
- 스냅숏 생성이나 AOF 재작성을 할 때 CoW를 사용.
- 즉, 쓰기 작업이 별로 없는 환경이라면 메모리를 효율적으로 사용 가능.

### Raft

분산 합의 알고리즘. 
- Raft에서는 각 서버가 다음 세 가지 역할 중 하나를 담당
  - 리더
  - 팔로워
  - 후보자
- 클라이언트 모든 요청은 리더를 통해 이루어짐. 리더는 모든 변경사항을 관리하고 후보자와 팔로워에게 변경사항을 로그로 전송함.
- Raft는 다음 문제에 대한 해결을 목표로 두고 있음.
  - 리더 선출
    - '기간'이라는 개념을 통해 기간 내에 리더를 선출하고 재투표가 이루어지기 전까지 그 상태가 지속
    - 초기 모든 서버는 팔로워 상태
    - 리더가 있는 경우, 리더는 팔로워에게 정기적으로 하트비를 보냄.
    - 팔로워는 일정 시간 동안 리더로부터 하트비를 받지 못하면 후보자 역할로 변경되고, 리더 선출 과정이 시작됨.
    - 후보자는 기간을 증가시키고 자신에게 투효한 후 RequestVote RPC를 브로드캐스트 함.
    - RequestVote RPC를 받은 서버는 먼저 보낸 송신자에게 투표
    - 과반수 서버로부터 투표를 받은 후보자가 리더로 승격
  - 로그 레플리케이션
    - 리더가 클라이언트의 요청을 받으면 AppendEntries RPC로 각 팔로워에게 로그를 전송. 이 시점에서는 각 변경사함이 서버 로그에 엔트리로 추가되었지만, 리더는 변경사항을 커밋하지 않은 상태
    - 이후 리더는 과반수의 팔로워의 응답을 받으면 변경사항을 커밋
    - 리더는 팔로워에게 변경사항이 커밋됨을 알려줌.
    - 서버 가에 로그 차이가 발생하면, 공통 부분까지 되돌아가 리더의 로그를 팔로워에 추가
  - 안정성
  
### HyperLogLog

메모리 사용량을 줄이면서 고유한 요소의 수를 계산하는 방법. 확률적인 방법이라 약간의 오차가 발생.



